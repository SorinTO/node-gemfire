<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Pivotal GemFire Native Client Cache Reference: gemfire::WritablePdxInstance Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacegemfire.html">gemfire</a>::<a class="el" href="classgemfire_1_1WritablePdxInstance.html">WritablePdxInstance</a></div>
<h1>gemfire::WritablePdxInstance Class Reference</h1><!-- doxytag: class="gemfire::WritablePdxInstance" --><!-- doxytag: inherits="gemfire::PdxInstance" -->Inherits <a class="el" href="classgemfire_1_1PdxInstance.html">gemfire::PdxInstance</a>.
<p>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> is a <a class="el" href="classgemfire_1_1PdxInstance.html">PdxInstance</a> that also supports field modification using the <a class="el" href="classgemfire_1_1WritablePdxInstance.html#5c7e0e748a9085800f0d5b050a458593">setField</a> method. 
<p>
To get a <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> call <a class="el" href="classgemfire_1_1PdxInstance.html#31293eeb29d2d1d7f84257a092dead64">PdxInstance#createWriter</a>. <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classgemfire_1_1SharedPtr.html">WritablePdxInstancePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#31293eeb29d2d1d7f84257a092dead64">createWriter</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates and returns a <a class="el" href="classgemfire_1_1WritablePdxInstance.html">WritablePdxInstance</a> whose initial values are those of this <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a>.  <a href="#31293eeb29d2d1d7f84257a092dead64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#42a6353d9df67f933ab4d0bf02edfe93">fromData</a> (<a class="el" href="classgemfire_1_1SharedPtr.html">PdxReaderPtr</a> input)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1Serializable.html">Serializable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#6ac266d42898eac8e6022e8285eb5c61">fromData</a> (<a class="el" href="classgemfire_1_1DataInput.html">DataInput</a> &amp;input)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#852676a38588ad52f1239c14842ede7d">getClassName</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the full name of the class that this pdx instance represents.  <a href="#852676a38588ad52f1239c14842ede7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#ac98a179cbaa037fc4ce9ef0c34a968b">getField</a> (const char *fieldname, <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableObjectArrayPtr</a> &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in CacheableObjectArrayPtr type out param.  <a href="#ac98a179cbaa037fc4ce9ef0c34a968b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#adadd3ca863c863478562b15cd3bd6e2">getField</a> (const char *fieldName, int8_t ***value, int32_t &amp;arrayLength, int32_t *&amp;elementLength) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in array of byte arrays type out param.  <a href="#adadd3ca863c863478562b15cd3bd6e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#bb294770f831a5b8ab8b7761f199a87b">getField</a> (const char *fieldname, <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableDatePtr</a> &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in CacheableDatePtr type out param.  <a href="#bb294770f831a5b8ab8b7761f199a87b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#53514bbaeae92eaf2eeccf8e283909a8">getField</a> (const char *fieldname, char ***value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in char* array type out param.  <a href="#53514bbaeae92eaf2eeccf8e283909a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#70425facddfe2d90854f150821029f8f">getField</a> (const char *fieldname, wchar_t ***value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in wchar_t* array type out param.  <a href="#70425facddfe2d90854f150821029f8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#e59a1266cc44f80ac75eeb4aca1c8870">getField</a> (const char *fieldname, char **value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in char* type out param.  <a href="#e59a1266cc44f80ac75eeb4aca1c8870"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#ca32d9e6d9b9243b26a912bc82453443">getField</a> (const char *fieldname, wchar_t **value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in wchar_t* type out param.  <a href="#ca32d9e6d9b9243b26a912bc82453443"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#2d77323dd77ba75ebce204fc85517157">getField</a> (const char *fieldName, char **value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in char array type out param.  <a href="#2d77323dd77ba75ebce204fc85517157"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#0a6f4879bab731d389707eb651948400">getField</a> (const char *fieldName, wchar_t **value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in wchar_t array type out param.  <a href="#0a6f4879bab731d389707eb651948400"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#50c547963de9428e1c4d5ac6a0957fef">getField</a> (const char *fieldname, double **value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in double array type out param.  <a href="#50c547963de9428e1c4d5ac6a0957fef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#2c835ea9020cdef23c5d7ef0fe9ef5ea">getField</a> (const char *fieldname, float **value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in float array type out param.  <a href="#2c835ea9020cdef23c5d7ef0fe9ef5ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#d607844033c82fe89b794bc29c8121d7">getField</a> (const char *fieldname, int64_t **value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in int64_t array type out param.  <a href="#d607844033c82fe89b794bc29c8121d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#ae44f582e306634c23d4f99ff53ced55">getField</a> (const char *fieldname, int32_t **value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in int32_t array type out param.  <a href="#ae44f582e306634c23d4f99ff53ced55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#f110926797e7ae135f53fccd84100f88">getField</a> (const char *fieldname, int16_t **value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in int16_t array type out param.  <a href="#f110926797e7ae135f53fccd84100f88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#04704036d8b1a6d136a98c243e5295cf">getField</a> (const char *fieldname, unsigned char **value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in unsigned char array type out param.  <a href="#04704036d8b1a6d136a98c243e5295cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#59ff3ab71132524a2d775af354943f82">getField</a> (const char *fieldname, signed char **value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in signed char array type out param.  <a href="#59ff3ab71132524a2d775af354943f82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#a9cf6041af001038af34b1fb74018e90">getField</a> (const char *fieldname, bool **value, int32_t &amp;length) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in bool array type out param.  <a href="#a9cf6041af001038af34b1fb74018e90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#ef9f737f42ab01ab343a26e2728eb68a">getField</a> (const char *fieldName, char &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in char type out param.  <a href="#ef9f737f42ab01ab343a26e2728eb68a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#2360298dac2ba1b9016f85923f0083a4">getField</a> (const char *fieldName, wchar_t &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in wchar_t type out param.  <a href="#2360298dac2ba1b9016f85923f0083a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#6674f7d9ed58349fe148445d7531d8c4">getField</a> (const char *fieldname, double &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in double type out param.  <a href="#6674f7d9ed58349fe148445d7531d8c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#3515ba0c2641963518d1762bf72b4b8c">getField</a> (const char *fieldname, float &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in float type out param.  <a href="#3515ba0c2641963518d1762bf72b4b8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#42725d5608e436844fbe7f7d48b7ffdd">getField</a> (const char *fieldname, int64_t &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in int64_t type out param.  <a href="#42725d5608e436844fbe7f7d48b7ffdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#7333dd5b7b9882ccdbc0449caeae1619">getField</a> (const char *fieldname, int32_t &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in int32_t type out param.  <a href="#7333dd5b7b9882ccdbc0449caeae1619"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#0ef929088af8fa93235da0fa03e8af4d">getField</a> (const char *fieldname, int16_t &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in int16_t type out param.  <a href="#0ef929088af8fa93235da0fa03e8af4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#ffded43b94e56c72d087b0e23570e65b">getField</a> (const char *fieldname, unsigned char &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in unsigned char type out param.  <a href="#ffded43b94e56c72d087b0e23570e65b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#12e28607b6d4bb5690958cc02eac77ca">getField</a> (const char *fieldname, signed char &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in signed char type out param.  <a href="#12e28607b6d4bb5690958cc02eac77ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#2d5288b47601c0898fef1cdf9b5d245a">getField</a> (const char *fieldname, bool &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in bool type out param.  <a href="#2d5288b47601c0898fef1cdf9b5d245a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#1e96ec4a322d1a772e5669659ae1d2a0">getField</a> (const char *fieldname, <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the named field and set its value in CacheablePtr type out param.  <a href="#1e96ec4a322d1a772e5669659ae1d2a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classgemfire_1_1SharedArrayPtr.html">CacheableStringArrayPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#4e8be742ef3a3e77bac8d87e3f4f666c">getFieldNames</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an unmodifiable list of the field names on this <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a>.  <a href="#4e8be742ef3a3e77bac8d87e3f4f666c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classgemfire_1_1SharedPtr.html">PdxSerializablePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#857a7885adfb5f1203a525abc91403c4">getObject</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deserializes and returns the domain object that this instance represents.  <a href="#857a7885adfb5f1203a525abc91403c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64">hasField</a> (const char *fieldname)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the named field exists and returns the result.  <a href="#76c99bd1e54a98a8681e22839c8a3a64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#76aceacfd679a2d4178f7195c75379b0">hashcode</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a hashcode based on the identity fields of this <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a>.  <a href="#76aceacfd679a2d4178f7195c75379b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#23277c2df5c0724e5984ec1faf6e4f1a">isIdentityField</a> (const char *fieldname)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the named field was <a class="el" href="classgemfire_1_1PdxWriter.html#f592a22d912ec896471b6c86ff98f25a">PdxWriter#markIdentityField</a>marked as an identity field.  <a href="#23277c2df5c0724e5984ec1faf6e4f1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#e10191a8665a010f51887d876b626137">objectSize</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the size of the object in bytes This is an internal method. </dd></dl>
 <a href="#e10191a8665a010f51887d876b626137"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#3086322c866505ff5b0f20c19b76b41c">operator==</a> (const <a class="el" href="classgemfire_1_1CacheableKey.html">CacheableKey</a> &amp;other) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the given <a class="el" href="classgemfire_1_1CacheableKey.html" title="Represents a cacheable key.">CacheableKey</a> derived object is equals to this instance.  <a href="#3086322c866505ff5b0f20c19b76b41c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#ffab6ba97afe0805836371168c9da815">setField</a> (const char *fieldName, <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableObjectArrayPtr</a> value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ffab6ba97afe0805836371168c9da815"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#5f9f141267456e5b4c3cb0f78ae14502">setField</a> (const char *fieldName, int8_t **value, int32_t arrayLength, int32_t *elementLength)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#5f9f141267456e5b4c3cb0f78ae14502"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#4a26e5b68932b0d3df56621b66ea8556">setField</a> (const char *fieldName, char **value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#4a26e5b68932b0d3df56621b66ea8556"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#31a526f1fe6d7c0065ed427f74fdfe70">setField</a> (const char *fieldName, wchar_t **value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#31a526f1fe6d7c0065ed427f74fdfe70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#188dbd7edb88ed0528db2e6d68259f91">setField</a> (const char *fieldName, char *value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#188dbd7edb88ed0528db2e6d68259f91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#adaac8cf9f9ef4d57f9b00468b0d9f53">setField</a> (const char *fieldName, wchar_t *value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#adaac8cf9f9ef4d57f9b00468b0d9f53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#9dfda57cfacc1e97a5615b1495360804">setField</a> (const char *fieldName, const char *value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#9dfda57cfacc1e97a5615b1495360804"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#2e066f3cec04b85e35a7ddd3708bc88a">setField</a> (const char *fieldName, const wchar_t *value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#2e066f3cec04b85e35a7ddd3708bc88a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#55cc1cd0bb3d61ddbd1242b933e59f71">setField</a> (const char *fieldName, double *value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#55cc1cd0bb3d61ddbd1242b933e59f71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#8e87b21138e6070b6002a92fa9b71735">setField</a> (const char *fieldName, float *value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#8e87b21138e6070b6002a92fa9b71735"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#b76b1306b8ddc65cef2bc9e69873ca9b">setField</a> (const char *fieldName, int64_t *value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#b76b1306b8ddc65cef2bc9e69873ca9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#e3a657691834a8dc09c45dbe523622eb">setField</a> (const char *fieldName, int32_t *value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#e3a657691834a8dc09c45dbe523622eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#e8844b6c8b0b419d4aa0f9842db1c4e2">setField</a> (const char *fieldName, int16_t *value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#e8844b6c8b0b419d4aa0f9842db1c4e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#e2626d6c348124df99b4008ae7c2e77a">setField</a> (const char *fieldName, unsigned char *value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#e2626d6c348124df99b4008ae7c2e77a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#89d75c034b28aa73c568fba5a04b2271">setField</a> (const char *fieldName, signed char *value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#89d75c034b28aa73c568fba5a04b2271"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#b9a999fcff55353d62ac21013b39a6f4">setField</a> (const char *fieldName, bool *value, int32_t length)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#b9a999fcff55353d62ac21013b39a6f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#6a21d82ff5a61960372b515eb90d7fa7">setField</a> (const char *fieldName, <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableDatePtr</a> value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#6a21d82ff5a61960372b515eb90d7fa7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#e7433feae9d2335e5d03ee9b8b92b65f">setField</a> (const char *fieldName, char value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#e7433feae9d2335e5d03ee9b8b92b65f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#dc39451635c2aea953e74b3e5f1ca73f">setField</a> (const char *fieldName, wchar_t value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#dc39451635c2aea953e74b3e5f1ca73f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#cf8f831b2e2ce06fb8abe09b49695121">setField</a> (const char *fieldName, double value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#cf8f831b2e2ce06fb8abe09b49695121"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#27d69cfe75d9bf275cc97d8a8d90a1dc">setField</a> (const char *fieldName, float value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#27d69cfe75d9bf275cc97d8a8d90a1dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#b254506cc50732a2831f10749e1cc52b">setField</a> (const char *fieldName, int64_t value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#b254506cc50732a2831f10749e1cc52b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#c55d40641acce46369c3577377831895">setField</a> (const char *fieldName, int32_t value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#c55d40641acce46369c3577377831895"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#6609a471a4dbcd664df73a2e82b96da4">setField</a> (const char *fieldName, int16_t value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#6609a471a4dbcd664df73a2e82b96da4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#b441d09fd30df3ea0d4dddea4d710e30">setField</a> (const char *fieldName, unsigned char value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#b441d09fd30df3ea0d4dddea4d710e30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#624e743c674945b210cad003d688d8ef">setField</a> (const char *fieldName, signed char value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#624e743c674945b210cad003d688d8ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#c15e1690c842bfd4ba1e479e974a2e62">setField</a> (const char *fieldName, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#c15e1690c842bfd4ba1e479e974a2e62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#5c7e0e748a9085800f0d5b050a458593">setField</a> (const char *fieldName, <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#5c7e0e748a9085800f0d5b050a458593"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#77141adb39201aad9b1e03a39369ed8e">toData</a> (<a class="el" href="classgemfire_1_1SharedPtr.html">PdxWriterPtr</a> output)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#695e48f19b5fd19d3d84303248380040">toData</a> (<a class="el" href="classgemfire_1_1DataOutput.html">DataOutput</a> &amp;output) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classgemfire_1_1SharedPtr.html">CacheableStringPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1PdxInstance.html#3570eaa1ccc8e0f6c898655bbf13c588">toString</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints out all of the identity fields of this <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a>.  <a href="#3570eaa1ccc8e0f6c898655bbf13c588"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#806c08245e45b6ff536aac80761a2c13">~WritablePdxInstance</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1WritablePdxInstance.html#506e1917dd609cf63bade2a6e82700ed">WritablePdxInstance</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="806c08245e45b6ff536aac80761a2c13"></a><!-- doxytag: member="gemfire::WritablePdxInstance::~WritablePdxInstance" ref="806c08245e45b6ff536aac80761a2c13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual gemfire::WritablePdxInstance::~WritablePdxInstance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
public methods destructor 
</div>
</div><p>
<a class="anchor" name="506e1917dd609cf63bade2a6e82700ed"></a><!-- doxytag: member="gemfire::WritablePdxInstance::WritablePdxInstance" ref="506e1917dd609cf63bade2a6e82700ed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gemfire::WritablePdxInstance::WritablePdxInstance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
constructors 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="31293eeb29d2d1d7f84257a092dead64"></a><!-- doxytag: member="gemfire::WritablePdxInstance::createWriter" ref="31293eeb29d2d1d7f84257a092dead64" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">WritablePdxInstancePtr</a> gemfire::PdxInstance::createWriter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates and returns a <a class="el" href="classgemfire_1_1WritablePdxInstance.html">WritablePdxInstance</a> whose initial values are those of this <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a>. 
<p>
This call returns a copy of the current field values so modifications made to the returned value will not modify this <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a>. <dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classgemfire_1_1WritablePdxInstance.html">WritablePdxInstance</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="42a6353d9df67f933ab4d0bf02edfe93"></a><!-- doxytag: member="gemfire::WritablePdxInstance::fromData" ref="42a6353d9df67f933ab4d0bf02edfe93" args="(PdxReaderPtr input)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::fromData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">PdxReaderPtr</a>&nbsp;</td>
          <td class="paramname"> <em>input</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deserialize this object. This is an internal method. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classgemfire_1_1PdxReader.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization...">PdxReader</a></em>&nbsp;</td><td>to Deserialize the PDX object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6ac266d42898eac8e6022e8285eb5c61"></a><!-- doxytag: member="gemfire::WritablePdxInstance::fromData" ref="6ac266d42898eac8e6022e8285eb5c61" args="(DataInput &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1Serializable.html">Serializable</a>* gemfire::PdxInstance::fromData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1DataInput.html">DataInput</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
deserialize this object, typical implementation should return the 'this' pointer. This is an internal method. 
</div>
</div><p>
<a class="anchor" name="852676a38588ad52f1239c14842ede7d"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getClassName" ref="852676a38588ad52f1239c14842ede7d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* gemfire::PdxInstance::getClassName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the full name of the class that this pdx instance represents. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the name of the class that this pdx instance represents. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> typeid is not defined yet, to get classname or if PdxType is not defined for <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac98a179cbaa037fc4ce9ef0c34a968b"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="ac98a179cbaa037fc4ce9ef0c34a968b" args="(const char *fieldname, CacheableObjectArrayPtr &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">CacheableObjectArrayPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in CacheableObjectArrayPtr type out param. 
<p>
For deserialization C++ Native Client requires the domain class to be registered. CacheableObjectArrayPtr type is corresponding to java Object[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with CacheableObjectArrayPtr type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Serializable.html#6a2b0690cd9ce93d14234304073b2ed7">Serializable::registerPdxType</a> <p>
<a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="adadd3ca863c863478562b15cd3bd6e2"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="adadd3ca863c863478562b15cd3bd6e2" args="(const char *fieldName, int8_t ***value, int32_t &amp;arrayLength, int32_t *&amp;elementLength) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t ***&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&amp;&nbsp;</td>
          <td class="paramname"> <em>elementLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in array of byte arrays type out param. 
<p>
int8_t** type is corresponding to java byte[][] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with array of byte arrays type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arrayLength</em>&nbsp;</td><td>arrayLength is set to the number of byte arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elementLength</em>&nbsp;</td><td>elementLength is set to individual byte array lengths. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bb294770f831a5b8ab8b7761f199a87b"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="bb294770f831a5b8ab8b7761f199a87b" args="(const char *fieldname, CacheableDatePtr &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">CacheableDatePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in CacheableDatePtr type out param. 
<p>
CacheableDatePtr type is corresponding to java Java.util.date type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with CacheableDatePtr type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="53514bbaeae92eaf2eeccf8e283909a8"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="53514bbaeae92eaf2eeccf8e283909a8" args="(const char *fieldname, char ***value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in char* array type out param. 
<p>
char** type is corresponding to java String[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with char* array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of char** elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="70425facddfe2d90854f150821029f8f"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="70425facddfe2d90854f150821029f8f" args="(const char *fieldname, wchar_t ***value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t ***&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in wchar_t* array type out param. 
<p>
wchar_t** type is corresponding to java String[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with wchar_t* array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of wchar_t** elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e59a1266cc44f80ac75eeb4aca1c8870"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="e59a1266cc44f80ac75eeb4aca1c8870" args="(const char *fieldname, char **value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in char* type out param. 
<p>
char* type is corresponding to java String type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with char* type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca32d9e6d9b9243b26a912bc82453443"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="ca32d9e6d9b9243b26a912bc82453443" args="(const char *fieldname, wchar_t **value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t **&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in wchar_t* type out param. 
<p>
wchar_t* type is corresponding to java String type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with wchar_t type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2d77323dd77ba75ebce204fc85517157"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="2d77323dd77ba75ebce204fc85517157" args="(const char *fieldName, char **value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in char array type out param. 
<p>
char* type is corresponding to java String type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with char array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of char* elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0a6f4879bab731d389707eb651948400"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="0a6f4879bab731d389707eb651948400" args="(const char *fieldName, wchar_t **value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in wchar_t array type out param. 
<p>
wchar_t* type is corresponding to java String type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with wchar_t array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of wchar_t* elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="50c547963de9428e1c4d5ac6a0957fef"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="50c547963de9428e1c4d5ac6a0957fef" args="(const char *fieldname, double **value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in double array type out param. 
<p>
double* type is corresponding to java double[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with double array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of double elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2c835ea9020cdef23c5d7ef0fe9ef5ea"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="2c835ea9020cdef23c5d7ef0fe9ef5ea" args="(const char *fieldname, float **value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in float array type out param. 
<p>
float* type is corresponding to java float[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with float array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of float elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d607844033c82fe89b794bc29c8121d7"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="d607844033c82fe89b794bc29c8121d7" args="(const char *fieldname, int64_t **value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in int64_t array type out param. 
<p>
int64_t* type is corresponding to java long[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with int64_t array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of int64_t elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae44f582e306634c23d4f99ff53ced55"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="ae44f582e306634c23d4f99ff53ced55" args="(const char *fieldname, int32_t **value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in int32_t array type out param. 
<p>
int32_t* type is corresponding to java int[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with int32_t array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of int32_t elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f110926797e7ae135f53fccd84100f88"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="f110926797e7ae135f53fccd84100f88" args="(const char *fieldname, int16_t **value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in int16_t array type out param. 
<p>
int16_t* type is corresponding to java short[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with int16_t array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of int16_t elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="04704036d8b1a6d136a98c243e5295cf"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="04704036d8b1a6d136a98c243e5295cf" args="(const char *fieldname, unsigned char **value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in unsigned char array type out param. 
<p>
unsigned char* type is corresponding to java byte[] type. For C++ on Windows and Linux, unsigned char* type is corresponding to int8_t* type. However C++ users on Solaris should always use this api after casting int8_t* to unsigned char*. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with unsigned char array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of unsigned char elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="59ff3ab71132524a2d775af354943f82"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="59ff3ab71132524a2d775af354943f82" args="(const char *fieldname, signed char **value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in signed char array type out param. 
<p>
signed char* type is corresponding to java byte[] type. For C++ on Windows and Linux, signed char* type is corresponding to int8_t* type. However C++ users on Solaris should always use this api after casting int8_t* to signed char*. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with signed char array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of signed char elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a9cf6041af001038af34b1fb74018e90"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="a9cf6041af001038af34b1fb74018e90" args="(const char *fieldname, bool **value, int32_t &amp;length) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in bool array type out param. 
<p>
bool* type is corresponding to java boolean[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with bool array type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length is set with number of bool elements. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ef9f737f42ab01ab343a26e2728eb68a"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="ef9f737f42ab01ab343a26e2728eb68a" args="(const char *fieldName, char &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in char type out param. 
<p>
char type is corresponding to java char type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with char type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2360298dac2ba1b9016f85923f0083a4"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="2360298dac2ba1b9016f85923f0083a4" args="(const char *fieldName, wchar_t &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in wchar_t type out param. 
<p>
wchar_t type is corresponding to java char type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with wchar_t type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6674f7d9ed58349fe148445d7531d8c4"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="6674f7d9ed58349fe148445d7531d8c4" args="(const char *fieldname, double &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in double type out param. 
<p>
double type is corresponding to java double type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with double type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3515ba0c2641963518d1762bf72b4b8c"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="3515ba0c2641963518d1762bf72b4b8c" args="(const char *fieldname, float &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in float type out param. 
<p>
float type is corresponding to java float type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with float type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="42725d5608e436844fbe7f7d48b7ffdd"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="42725d5608e436844fbe7f7d48b7ffdd" args="(const char *fieldname, int64_t &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in int64_t type out param. 
<p>
int64_t type is corresponding to java long type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with int64_t type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7333dd5b7b9882ccdbc0449caeae1619"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="7333dd5b7b9882ccdbc0449caeae1619" args="(const char *fieldname, int32_t &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in int32_t type out param. 
<p>
int32_t type is corresponding to java int type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with int32_t type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0ef929088af8fa93235da0fa03e8af4d"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="0ef929088af8fa93235da0fa03e8af4d" args="(const char *fieldname, int16_t &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in int16_t type out param. 
<p>
int16_t type is corresponding to java short type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with int16_t type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ffded43b94e56c72d087b0e23570e65b"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="ffded43b94e56c72d087b0e23570e65b" args="(const char *fieldname, unsigned char &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in unsigned char type out param. 
<p>
unsigned char type is corresponding to java byte type. For C++ on Windows and Linux, unsigned char type is corresponding to int8_t type. However C++ users on Solaris should always use this api after casting int8_t to unsigned char. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with unsigned char type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="12e28607b6d4bb5690958cc02eac77ca"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="12e28607b6d4bb5690958cc02eac77ca" args="(const char *fieldname, signed char &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in signed char type out param. 
<p>
signed char type is corresponding to java byte type. For C++ on Windows and Linux, signed char type is corresponding to int8_t type. However C++ users on Solaris should always use this api after casting int8_t to signed char. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with signed char type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2d5288b47601c0898fef1cdf9b5d245a"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="2d5288b47601c0898fef1cdf9b5d245a" args="(const char *fieldname, bool &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in bool type out param. 
<p>
bool type is corresponding to java boolean type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with bool type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e96ec4a322d1a772e5669659ae1d2a0"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getField" ref="1e96ec4a322d1a772e5669659ae1d2a0" args="(const char *fieldname, CacheablePtr &amp;value) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::getField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the named field and set its value in CacheablePtr type out param. 
<p>
CacheablePtr type is corresponding to java object type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>name of the field to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value of the field to be set with CacheablePtr type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> doesn't has the named field. For deserialization C++ Native Client requires the domain class to be registered.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Serializable.html#6a2b0690cd9ce93d14234304073b2ed7">Serializable::registerPdxType</a> <p>
<a class="el" href="classgemfire_1_1PdxInstance.html#76c99bd1e54a98a8681e22839c8a3a64" title="Checks if the named field exists and returns the result.">PdxInstance::hasField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e8be742ef3a3e77bac8d87e3f4f666c"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getFieldNames" ref="4e8be742ef3a3e77bac8d87e3f4f666c" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedArrayPtr.html">CacheableStringArrayPtr</a> gemfire::PdxInstance::getFieldNames           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return an unmodifiable list of the field names on this <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an unmodifiable list of the field names on this <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="857a7885adfb5f1203a525abc91403c4"></a><!-- doxytag: member="gemfire::WritablePdxInstance::getObject" ref="857a7885adfb5f1203a525abc91403c4" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">PdxSerializablePtr</a> gemfire::PdxInstance::getObject           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deserializes and returns the domain object that this instance represents. 
<p>
For deserialization C++ Native Client requires the domain class to be registered. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the deserialized domain object.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Serializable.html#6a2b0690cd9ce93d14234304073b2ed7">Serializable::registerPdxType</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="76c99bd1e54a98a8681e22839c8a3a64"></a><!-- doxytag: member="gemfire::WritablePdxInstance::hasField" ref="76c99bd1e54a98a8681e22839c8a3a64" args="(const char *fieldname)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::PdxInstance::hasField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the named field exists and returns the result. 
<p>
This can be useful when writing code that handles more than one version of a PDX class. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>the name of the field to check </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if the named field exists; otherwise <code>false</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="76aceacfd679a2d4178f7195c75379b0"></a><!-- doxytag: member="gemfire::WritablePdxInstance::hashcode" ref="76aceacfd679a2d4178f7195c75379b0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t gemfire::PdxInstance::hashcode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates a hashcode based on the identity fields of this <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a>. 
<p>
If a <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> has marked identity fields using <a class="el" href="classgemfire_1_1PdxWriter.html#f592a22d912ec896471b6c86ff98f25a">PdxWriter#markIdentityField</a> then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields.  For deserialization C++ Native Client requires the domain class to be registered. If the field is an array then all array elements are used for hashcode computation. Otherwise the raw bytes of its value are used to compute the hash code. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the field contains an element that is not of <a class="el" href="classgemfire_1_1CacheableKey.html" title="Represents a cacheable key.">CacheableKey</a> derived type.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Serializable.html#6a2b0690cd9ce93d14234304073b2ed7">Serializable::registerPdxType</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="23277c2df5c0724e5984ec1faf6e4f1a"></a><!-- doxytag: member="gemfire::WritablePdxInstance::isIdentityField" ref="23277c2df5c0724e5984ec1faf6e4f1a" args="(const char *fieldname)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::PdxInstance::isIdentityField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the named field was <a class="el" href="classgemfire_1_1PdxWriter.html#f592a22d912ec896471b6c86ff98f25a">PdxWriter#markIdentityField</a>marked as an identity field. 
<p>
Note that if no fields have been marked then all the fields are used as identity fields even though this method will return <code>false</code> since none of them have been <em>marked</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldname</em>&nbsp;</td><td>the name of the field to check </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if the named field exists and was marked as an identify field; otherwise <code>false</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e10191a8665a010f51887d876b626137"></a><!-- doxytag: member="gemfire::WritablePdxInstance::objectSize" ref="e10191a8665a010f51887d876b626137" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t gemfire::PdxInstance::objectSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the size of the object in bytes This is an internal method. </dd></dl>

<p>
It is used in case of heap LRU property is set. 
</div>
</div><p>
<a class="anchor" name="3086322c866505ff5b0f20c19b76b41c"></a><!-- doxytag: member="gemfire::WritablePdxInstance::operator==" ref="3086322c866505ff5b0f20c19b76b41c" args="(const CacheableKey &amp;other) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::PdxInstance::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1CacheableKey.html">CacheableKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the given <a class="el" href="classgemfire_1_1CacheableKey.html" title="Represents a cacheable key.">CacheableKey</a> derived object is equals to this instance. 
<p>
If <code>other</code> is not a <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> then it is not equal to this instance. NOTE: Even if <code>other</code> is the result of calling <a class="el" href="classgemfire_1_1PdxInstance.html#857a7885adfb5f1203a525abc91403c4">getObject()</a> it will not be equal to this instance. <p>
Otherwise equality of two PdxInstances is determined as follows: <ol>
<li>
The domain class name must be equal for both PdxInstances </li>
<li>
Each identity field must be equal. </li>
</ol>
If one of the instances does not have a field that the other one does then equals will assume it has the field with a default value. If a <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> has marked identity fields using <a class="el" href="classgemfire_1_1PdxWriter.html#f592a22d912ec896471b6c86ff98f25a">markIdentityField</a> then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields. <p>
An identity field is equal if all the following are true: <ol>
<li>
The field name is equal. </li>
<li>
The field type is equal. </li>
<li>
The field value is equal. </li>
</ol>
If an identity field is of type derived from <code>Cacheable</code> then it is deserialized. For deserialization C++ Native Client requires the domain class to be registered. If the deserialized object is an array then all array elements are used to determine equality. If an identity field is of type <code><a class="el" href="classgemfire_1_1CacheableObjectArray.html" title="Implement an immutable Vector of Cacheable objects that can serve as a distributable...">CacheableObjectArray</a></code> then it is deserialized and all array elements are used to determine equality. For all other field types the value does not need to be deserialized. Instead the serialized raw bytes are compared and used to determine equality. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>the other instance to compare to this. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this instance is equal to <code>other</code>. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the field contains an element that is not of <a class="el" href="classgemfire_1_1CacheableKey.html" title="Represents a cacheable key.">CacheableKey</a> derived type.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Serializable.html#6a2b0690cd9ce93d14234304073b2ed7">Serializable::registerPdxType</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ffab6ba97afe0805836371168c9da815"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="ffab6ba97afe0805836371168c9da815" args="(const char *fieldName, CacheableObjectArrayPtr value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">CacheableObjectArrayPtr</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. CacheableObjectArrayPtr type is corresponding to java Object[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type CacheableObjectArrayPtr </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5f9f141267456e5b4c3cb0f78ae14502"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="5f9f141267456e5b4c3cb0f78ae14502" args="(const char *fieldName, int8_t **value, int32_t arrayLength, int32_t *elementLength)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>elementLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int8_t** type is corresponding to java byte[][] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type array of byte arrays </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arrayLength</em>&nbsp;</td><td>The number of byte arrays. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elementLength</em>&nbsp;</td><td>The lengths of individual byte arrays. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4a26e5b68932b0d3df56621b66ea8556"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="4a26e5b68932b0d3df56621b66ea8556" args="(const char *fieldName, char **value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char** type is corresponding to java String[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type char* array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in CString array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="31a526f1fe6d7c0065ed427f74fdfe70"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="31a526f1fe6d7c0065ed427f74fdfe70" args="(const char *fieldName, wchar_t **value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t **&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. wchar_t** type is corresponding to java String[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type wchar_t* array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in WCString array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="188dbd7edb88ed0528db2e6d68259f91"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="188dbd7edb88ed0528db2e6d68259f91" args="(const char *fieldName, char *value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char* type is corresponding to java char[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type char array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in char array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="adaac8cf9f9ef4d57f9b00468b0d9f53"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="adaac8cf9f9ef4d57f9b00468b0d9f53" args="(const char *fieldName, wchar_t *value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. wchar_t* type is corresponding to java char[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type wchar_t array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in wchar_t array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9dfda57cfacc1e97a5615b1495360804"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="9dfda57cfacc1e97a5615b1495360804" args="(const char *fieldName, const char *value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char* type is corresponding to java String type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type char* </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2e066f3cec04b85e35a7ddd3708bc88a"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="2e066f3cec04b85e35a7ddd3708bc88a" args="(const char *fieldName, const wchar_t *value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. wchar_t* type is corresponding to java String type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type wchar_t* </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="55cc1cd0bb3d61ddbd1242b933e59f71"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="55cc1cd0bb3d61ddbd1242b933e59f71" args="(const char *fieldName, double *value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. double* type is corresponding to java double[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type double array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in double array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8e87b21138e6070b6002a92fa9b71735"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="8e87b21138e6070b6002a92fa9b71735" args="(const char *fieldName, float *value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. float* type is corresponding to java float[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type float array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in float array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b76b1306b8ddc65cef2bc9e69873ca9b"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="b76b1306b8ddc65cef2bc9e69873ca9b" args="(const char *fieldName, int64_t *value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int64_t* type is corresponding to java long[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type int64_t array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in int64_t array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e3a657691834a8dc09c45dbe523622eb"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="e3a657691834a8dc09c45dbe523622eb" args="(const char *fieldName, int32_t *value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int32_t* type is corresponding to java int[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type int32_t array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in int32_t array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e8844b6c8b0b419d4aa0f9842db1c4e2"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="e8844b6c8b0b419d4aa0f9842db1c4e2" args="(const char *fieldName, int16_t *value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int16_t* type is corresponding to java short[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type int16_t array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in int16_t array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e2626d6c348124df99b4008ae7c2e77a"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="e2626d6c348124df99b4008ae7c2e77a" args="(const char *fieldName, unsigned char *value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. unsigned char* type is corresponding to java byte[] type. For C++ on Windows and Linux, unsigned char* type is corresponding to int8_t* type. However C++ users on Solaris should always use this api after casting int8_t* to unsigned char*. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type unsigned char array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in unsigned char array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="89d75c034b28aa73c568fba5a04b2271"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="89d75c034b28aa73c568fba5a04b2271" args="(const char *fieldName, signed char *value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. signed char* type is corresponding to java byte[] type. For C++ on Windows and Linux, signed char* type is corresponding to int8_t* type. However C++ users on Solaris should always use this api after casting int8_t* to signed char*. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type signed char array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in signed char array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b9a999fcff55353d62ac21013b39a6f4"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="b9a999fcff55353d62ac21013b39a6f4" args="(const char *fieldName, bool *value, int32_t length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. bool* type is corresponding to java boolean[] type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type bool array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of elements in bool array type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6a21d82ff5a61960372b515eb90d7fa7"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="6a21d82ff5a61960372b515eb90d7fa7" args="(const char *fieldName, CacheableDatePtr value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">CacheableDatePtr</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. CacheableDatePtr type is corresponding to java Java.util.date type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type CacheableDatePtr </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e7433feae9d2335e5d03ee9b8b92b65f"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="e7433feae9d2335e5d03ee9b8b92b65f" args="(const char *fieldName, char value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char type is corresponding to java char type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type char </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dc39451635c2aea953e74b3e5f1ca73f"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="dc39451635c2aea953e74b3e5f1ca73f" args="(const char *fieldName, wchar_t value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. wchar_t type is corresponding to java char type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type wchar_t </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cf8f831b2e2ce06fb8abe09b49695121"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="cf8f831b2e2ce06fb8abe09b49695121" args="(const char *fieldName, double value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. double type is corresponding to java double type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type double </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="27d69cfe75d9bf275cc97d8a8d90a1dc"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="27d69cfe75d9bf275cc97d8a8d90a1dc" args="(const char *fieldName, float value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. float type is corresponding to java float type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type float </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b254506cc50732a2831f10749e1cc52b"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="b254506cc50732a2831f10749e1cc52b" args="(const char *fieldName, int64_t value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int64_t type is corresponding to java long type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type int64_t </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c55d40641acce46369c3577377831895"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="c55d40641acce46369c3577377831895" args="(const char *fieldName, int32_t value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int32_t type is corresponding to java int type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type int32_t </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6609a471a4dbcd664df73a2e82b96da4"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="6609a471a4dbcd664df73a2e82b96da4" args="(const char *fieldName, int16_t value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int16_t type is corresponding to java short type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type int16_t </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b441d09fd30df3ea0d4dddea4d710e30"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="b441d09fd30df3ea0d4dddea4d710e30" args="(const char *fieldName, unsigned char value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. unsigned char type is corresponding to java byte type. For C++ on Windows and Linux, unsigned char type is corresponding to int8_t type. However C++ users on Solaris should always use this api after casting int8_t to unsigned char. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type unsigned char </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="624e743c674945b210cad003d688d8ef"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="624e743c674945b210cad003d688d8ef" args="(const char *fieldName, signed char value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. signed char type is corresponding to java byte type. For C++ on Windows and Linux, signed char type is corresponding to int8_t type. However C++ users on Solaris should always use this api after casting int8_t to signed char. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type signed char </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c15e1690c842bfd4ba1e479e974a2e62"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="c15e1690c842bfd4ba1e479e974a2e62" args="(const char *fieldName, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. bool type is corresponding to java boolean type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type bool </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5c7e0e748a9085800f0d5b050a458593"></a><!-- doxytag: member="gemfire::WritablePdxInstance::setField" ref="5c7e0e748a9085800f0d5b050a458593" args="(const char *fieldName, CacheablePtr value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::WritablePdxInstance::setField           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the existing named field to the given value. 
<p>
The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="classgemfire_1_1WritablePdxInstance.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. CacheablePtr type is corresponding to java object type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>name of the field whose value will be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value that will be set to the field of type CacheablePtr </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="77141adb39201aad9b1e03a39369ed8e"></a><!-- doxytag: member="gemfire::WritablePdxInstance::toData" ref="77141adb39201aad9b1e03a39369ed8e" args="(PdxWriterPtr output)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::toData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">PdxWriterPtr</a>&nbsp;</td>
          <td class="paramname"> <em>output</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
serialize this object in <a class="el" href="namespacegemfire.html" title="This namespace contains all the GemFire C++ API classes, enumerations and globals...">gemfire</a> PDX format. This is an internal method. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classgemfire_1_1PdxWriter.html" title="A PdxWriter will be passed to PdxSerializable.toData when it is serializing the domain...">PdxWriter</a></em>&nbsp;</td><td>to serialize the PDX object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="695e48f19b5fd19d3d84303248380040"></a><!-- doxytag: member="gemfire::WritablePdxInstance::toData" ref="695e48f19b5fd19d3d84303248380040" args="(DataOutput &amp;output) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::PdxInstance::toData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1DataOutput.html">DataOutput</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
serialize this object. This is an internal method. 
</div>
</div><p>
<a class="anchor" name="3570eaa1ccc8e0f6c898655bbf13c588"></a><!-- doxytag: member="gemfire::WritablePdxInstance::toString" ref="3570eaa1ccc8e0f6c898655bbf13c588" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableStringPtr</a> gemfire::PdxInstance::toString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints out all of the identity fields of this <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a>. 
<p>
If a <a class="el" href="classgemfire_1_1PdxInstance.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing...">PdxInstance</a> has marked identity fields using <a class="el" href="classgemfire_1_1PdxWriter.html#f592a22d912ec896471b6c86ff98f25a">PdxWriter#markIdentityField</a> then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields. For deserialization C++ Native Client requires the domain class to be registered.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Serializable.html#6a2b0690cd9ce93d14234304073b2ed7">Serializable::registerPdxType</a> </dd></dl>

</div>
</div><p>
<HR><address style="align: right;"><small>GemFire C++ Cache API Documentation</small></address>

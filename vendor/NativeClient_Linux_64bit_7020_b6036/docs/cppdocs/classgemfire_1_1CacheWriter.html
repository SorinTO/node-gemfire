<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Pivotal GemFire Native Client Cache Reference: gemfire::CacheWriter Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacegemfire.html">gemfire</a>::<a class="el" href="classgemfire_1_1CacheWriter.html">CacheWriter</a></div>
<h1>gemfire::CacheWriter Class Reference</h1><!-- doxytag: class="gemfire::CacheWriter" --><!-- doxytag: inherits="gemfire::SharedBase" -->Inherits <a class="el" href="classgemfire_1_1SharedBase.html">gemfire::SharedBase</a>.
<p>
<hr><a name="_details"></a><h2>Detailed Description</h2>
An application plug-in that can be installed on the region. 
<p>
Defines methods that are called BEFORE entry modification. A distributed region will typically have a single cache writer. If the application is designed such that all or most updates to a region occurs on a node, it is desirable to have the cache writer for the region to be installed at that node.<p>
<a class="el" href="classgemfire_1_1Cache.html" title="Cache are obtained from create method on the CacheFactory#create class.">Cache</a> writer invocations are initiated by the node where the entry or region modification occurs. If there is a local cache writer on the node where the change occurs, that is invoked. If there is no local cache writer , the system knows which of the nodes that have the region defined have a cache writer defined.<p>
Note that cache writer callbacks are synchronous callbacks and have the ability to veto the cache update. Since cache writer invocations require communications over the network, (especially if they are not colocated on the nodes where the change occurs) the use of cache writers presents a performance penalty.<p>
A user-defined object defined in the <a class="el" href="classgemfire_1_1RegionAttributes.html">RegionAttributes</a> that is called synchronously before a region or entry in the cache is modified.<p>
The typical use for a <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> is to update a database. Application writers should implement these methods to execute application-specific behavior before the cache is modified.<p>
Before the region is updated via a put, create, or destroy operation, GemFire will call a <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> that is installed anywhere in any participating cache for that region, preferring a local <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> if there is one. Usually there will be only one <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> in the distributed system. If there are multiple <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code>s available in the distributed system, the GemFire implementation always prefers one that is stored locally, or else picks one arbitrarily. In any case, only one <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> will be invoked.<p>
The <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> is capable of aborting the update to the cache by throwing a <code>CacheWriterException</code>. This exception or any runtime exception thrown by the <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> will abort the operation, and the exception will be propagated to the initiator of the operation, regardless of whether the initiator is in the same process as the <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1AttributesFactory.html#f2e4573f1c1cd0f3bf4d120b94ba90e7" title="Sets the cache writer for the next RegionAttributes created.">AttributesFactory::setCacheWriter</a> <p>
<a class="el" href="classgemfire_1_1RegionAttributes.html#e12b898c8118f1d48cafd0a8989389ff" title="Gets the cache writer for the region.">RegionAttributes::getCacheWriter</a> <p>
<a class="el" href="classgemfire_1_1AttributesMutator.html#622192a052dcab471020f01e43fe202d" title="Sets cache writer for region.">AttributesMutator::setCacheWriter</a> </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheWriter.html#4cd250e57ff679d8dd4d0142791e5bf6">beforeCreate</a> (const <a class="el" href="classgemfire_1_1EntryEvent.html">EntryEvent</a> &amp;event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called before an entry is created.  <a href="#4cd250e57ff679d8dd4d0142791e5bf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheWriter.html#73ca2d0f119df8e8098dd51bc29bc5c6">beforeDestroy</a> (const <a class="el" href="classgemfire_1_1EntryEvent.html">EntryEvent</a> &amp;event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called before an entry is destroyed.  <a href="#73ca2d0f119df8e8098dd51bc29bc5c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheWriter.html#d0ad06504cd3092355914d24b67aa4a0">beforeUpdate</a> (const <a class="el" href="classgemfire_1_1EntryEvent.html">EntryEvent</a> &amp;event)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called before an entry is updated.  <a href="#d0ad06504cd3092355914d24b67aa4a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheWriter.html#89c33c1151391ff117c042c60c436d65">close</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">RegionPtr</a> &amp;rp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when the region containing this callback is destroyed, when the cache is closed.  <a href="#89c33c1151391ff117c042c60c436d65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#327be04b1f16b21a84b654e62c8cb047">preserveSB</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically increment reference count.  <a href="#327be04b1f16b21a84b654e62c8cb047"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#197c0b015e8fa9656ea520a0fbd57008">refCount</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the reference count </dd></dl>
 <a href="#197c0b015e8fa9656ea520a0fbd57008"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#44da117cf90615f1302a5a70b5eb9d91">releaseSB</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically decrement reference count, the <a class="el" href="classgemfire_1_1SharedBase.html" title="This abstract base class is the base class of all user objects that have the shared...">SharedBase</a> object is automatically deleted when its reference count goes to zero.  <a href="#44da117cf90615f1302a5a70b5eb9d91"></a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="4cd250e57ff679d8dd4d0142791e5bf6"></a><!-- doxytag: member="gemfire::CacheWriter::beforeCreate" ref="4cd250e57ff679d8dd4d0142791e5bf6" args="(const EntryEvent &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::CacheWriter::beforeCreate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1EntryEvent.html">EntryEvent</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called before an entry is created. 
<p>
Entry creation is initiated by a <code>create</code>, a <code>put</code>, or a <code>get</code>. The <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> can determine whether this value comes from a <code>get</code> or not from <a class="el" href="">EntryEvent::isLoad</a>. The entry being created may already exist in the local cache where this <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> is installed, but it does not yet exist in the cache where the operation was initiated. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td><a class="el" href="classgemfire_1_1EntryEvent.html" title="Represents an entry event affecting an entry, including its identity and the the...">EntryEvent</a> denotes the event object associated with creating the entry</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#ecb3c05a5fa94a1950a9fb2cb90ec5eb" title="Creates a new entry in this region with the specified key and value, providing a...">Region::create</a> <p>
<a class="el" href="classgemfire_1_1Region.html#ca7c7bf2eb5d466fa3f5dfa6f9b8d392" title="Places a new value into an entry in this region with the specified key, providing...">Region::put</a> <p>
<a class="el" href="classgemfire_1_1Region.html#6417a042b32bba4bd39011dc5909f4c1" title="Returns the value associated with the specified key, passing the callback argument...">Region::get</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="73ca2d0f119df8e8098dd51bc29bc5c6"></a><!-- doxytag: member="gemfire::CacheWriter::beforeDestroy" ref="73ca2d0f119df8e8098dd51bc29bc5c6" args="(const EntryEvent &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::CacheWriter::beforeDestroy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1EntryEvent.html">EntryEvent</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called before an entry is destroyed. 
<p>
The entry being destroyed may or may not exist in the local cache where the <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> is installed. This method is <em>not</em> called as a result of expiration or <a class="el" href="classgemfire_1_1Region.html#4ad8b7c842587d3a463bc6f42de13e0d">Region::localDestroyRegion</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td><a class="el" href="classgemfire_1_1EntryEvent.html" title="Represents an entry event affecting an entry, including its identity and the the...">EntryEvent</a> denotes the event object associated with destroying the entry</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter...">Region::destroy</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d0ad06504cd3092355914d24b67aa4a0"></a><!-- doxytag: member="gemfire::CacheWriter::beforeUpdate" ref="d0ad06504cd3092355914d24b67aa4a0" args="(const EntryEvent &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::CacheWriter::beforeUpdate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1EntryEvent.html">EntryEvent</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>event</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called before an entry is updated. 
<p>
The entry update is initiated by a <code>put</code> or a <code>get</code> that causes the loader to update an existing entry. The entry previously existed in the cache where the operation was initiated, although the old value may have been NULLPTR. The entry being updated may or may not exist in the local cache where the <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> is installed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td><a class="el" href="classgemfire_1_1EntryEvent.html" title="Represents an entry event affecting an entry, including its identity and the the...">EntryEvent</a> denotes the event object associated with updating the entry</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#ca7c7bf2eb5d466fa3f5dfa6f9b8d392" title="Places a new value into an entry in this region with the specified key, providing...">Region::put</a> <p>
<a class="el" href="classgemfire_1_1Region.html#6417a042b32bba4bd39011dc5909f4c1" title="Returns the value associated with the specified key, passing the callback argument...">Region::get</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="89c33c1151391ff117c042c60c436d65"></a><!-- doxytag: member="gemfire::CacheWriter::close" ref="89c33c1151391ff117c042c60c436d65" args="(const RegionPtr &amp;rp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::CacheWriter::close           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">RegionPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when the region containing this callback is destroyed, when the cache is closed. 
<p>
Implementations should clean up any external resources, such as database connections. Any runtime exceptions this method throws will be logged.<p>
It is possible for this method to be called multiple times on a single callback instance, so implementations must be tolerant of this.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Cache.html#9a629fb18b9cbdca3e11c30c77bc0e27" title="Terminates this object cache and releases all the local resources.">Cache::close</a> <p>
<a class="el" href="classgemfire_1_1Region.html#2b07a940ee17e375c45421e85b27a8ff" title="Destroys the whole region and provides a user-defined parameter object to any CacheWriter...">Region::destroyRegion</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="327be04b1f16b21a84b654e62c8cb047"></a><!-- doxytag: member="gemfire::CacheWriter::preserveSB" ref="327be04b1f16b21a84b654e62c8cb047" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::SharedBase::preserveSB           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Atomically increment reference count. 
<p>

</div>
</div><p>
<a class="anchor" name="197c0b015e8fa9656ea520a0fbd57008"></a><!-- doxytag: member="gemfire::CacheWriter::refCount" ref="197c0b015e8fa9656ea520a0fbd57008" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t gemfire::SharedBase::refCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the reference count </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="44da117cf90615f1302a5a70b5eb9d91"></a><!-- doxytag: member="gemfire::CacheWriter::releaseSB" ref="44da117cf90615f1302a5a70b5eb9d91" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::SharedBase::releaseSB           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Atomically decrement reference count, the <a class="el" href="classgemfire_1_1SharedBase.html" title="This abstract base class is the base class of all user objects that have the shared...">SharedBase</a> object is automatically deleted when its reference count goes to zero. 
<p>

</div>
</div><p>
<HR><address style="align: right;"><small>GemFire C++ Cache API Documentation</small></address>

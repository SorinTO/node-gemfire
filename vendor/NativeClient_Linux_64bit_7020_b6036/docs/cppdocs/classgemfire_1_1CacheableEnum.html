<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Pivotal GemFire Native Client Cache Reference: gemfire::CacheableEnum Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacegemfire.html">gemfire</a>::<a class="el" href="classgemfire_1_1CacheableEnum.html">CacheableEnum</a></div>
<h1>gemfire::CacheableEnum Class Reference</h1><!-- doxytag: class="gemfire::CacheableEnum" --><!-- doxytag: inherits="gemfire::CacheableKey" -->Inherits <a class="el" href="classgemfire_1_1CacheableKey.html">gemfire::CacheableKey</a>.
<p>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Since C++ enums cannot be directly passed as a parameter to PdxWriter's writeObject and PdxReader's readObject api wrap C++ enum in to a immutable wrapper <a class="el" href="classgemfire_1_1CacheableEnum.html" title="Since C++ enums cannot be directly passed as a parameter to PdxWriter&#39;s writeObject...">CacheableEnum</a> class type by specifying enum class name, enum value name and its ordinal. 
<p>
C++ enum allows explicit setting of ordinal number, but it is up to the user to map java enumName with that of C++ enumName. Currently this wrapper only works as part of PdxSerializable member object and cannot be directly used in <a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a> operations.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1PdxWriter.html#38d6744cd25b9f807e3b6d73516c2451" title="Writes the named field with the given value to the serialized form.">PdxWriter::writeObject</a> <p>
<a class="el" href="classgemfire_1_1PdxReader.html#88b5652826c82fd91a0e2be8d3b4f0f1" title="Read a CacheablePtr value from the PdxReader.">PdxReader::readObject</a> </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#e4a5fe0956a7ec2c6d820d06b1646162">classId</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Serializable.html#1f9643ad4a462b08ad2c3145db09e1e1">DSFID</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1Serializable.html">Serializable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#bb944671e37541d9aafeb1bcad8b0f1f">fromData</a> (<a class="el" href="classgemfire_1_1DataInput.html">DataInput</a> &amp;input)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#8c34881d6b1ab6d32c3495130db4013e">getEnumClassName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>enum class name. </dd></dl>
 <a href="#8c34881d6b1ab6d32c3495130db4013e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#797f7576b815836b671b3a05cb952868">getEnumName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>enum name. </dd></dl>
 <a href="#797f7576b815836b671b3a05cb952868"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#cb43a4094f6ffb71fa507257a8a063af">getEnumOrdinal</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>enum ordinal. </dd></dl>
 <a href="#cb43a4094f6ffb71fa507257a8a063af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#05e2210bc53683348cd3919abecdebe7">hashcode</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the hashcode for this key. </dd></dl>
 <a href="#05e2210bc53683348cd3919abecdebe7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableKey.html#6449a06bf4d92683cda94330f657c9f2">logString</a> (char *buffer, int32_t maxLength) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the string form of a key into a char* buffer for logging purposes.  <a href="#6449a06bf4d92683cda94330f657c9f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#dc3651651a796d7be87e506ff5fdefe2">objectSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the size of the object in bytes </dd></dl>
 <a href="#dc3651651a796d7be87e506ff5fdefe2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#1a52cbcbff655cfeb9955ce68e1470d0">operator==</a> (const <a class="el" href="classgemfire_1_1CacheableKey.html">CacheableKey</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>true if this key matches other. </dd></dl>
 <a href="#1a52cbcbff655cfeb9955ce68e1470d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#327be04b1f16b21a84b654e62c8cb047">preserveSB</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically increment reference count.  <a href="#327be04b1f16b21a84b654e62c8cb047"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#197c0b015e8fa9656ea520a0fbd57008">refCount</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the reference count </dd></dl>
 <a href="#197c0b015e8fa9656ea520a0fbd57008"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#44da117cf90615f1302a5a70b5eb9d91">releaseSB</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically decrement reference count, the <a class="el" href="classgemfire_1_1SharedBase.html" title="This abstract base class is the base class of all user objects that have the shared...">SharedBase</a> object is automatically deleted when its reference count goes to zero.  <a href="#44da117cf90615f1302a5a70b5eb9d91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#246038ec85a4d3a375c529e0c14847c0">toData</a> (<a class="el" href="classgemfire_1_1DataOutput.html">DataOutput</a> &amp;output) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classgemfire_1_1SharedPtr.html">CacheableStringPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#98690cc2b9fd67d2baf6eb14f36ccf10">toString</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display this object as c string.  <a href="#98690cc2b9fd67d2baf6eb14f36ccf10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#b30dc6ed8e27ff3525fef477fa44ee44">typeId</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#6f6f50ae157f68846d046837d91b4726">~CacheableEnum</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#6f6f50ae157f68846d046837d91b4726"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PRIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableKey.html#07cf1fa0052048288475d2037962fbaf">create</a> (const PRIM value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method that creates the key type that matches the type of value.  <a href="#07cf1fa0052048288475d2037962fbaf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableEnumPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#7eb680fe8ba2e2fc055c3ae866e6d60a">create</a> (const char *enumClassName, const char *enumName, int32_t ordinal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method for creating an instance of <a class="el" href="classgemfire_1_1CacheableEnum.html" title="Since C++ enums cannot be directly passed as a parameter to PdxWriter&#39;s writeObject...">CacheableEnum</a>.  <a href="#7eb680fe8ba2e2fc055c3ae866e6d60a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classgemfire_1_1Serializable.html">Serializable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1CacheableEnum.html#65ea21a3e9feb8498f4aa2bf03732c10">createDeserializable</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Serializable.html#850b38d661bf13c9a053f45e2cec0a9f">registerPdxSerializer</a> (<a class="el" href="classgemfire_1_1SharedPtr.html">PdxSerializerPtr</a> pdxSerializer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register the PDX serializer which can handle serialization for instances of user domain classes.  <a href="#850b38d661bf13c9a053f45e2cec0a9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Serializable.html#6a2b0690cd9ce93d14234304073b2ed7">registerPdxType</a> (TypeFactoryMethodPdx creationFunction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Serializable.html#b73c122ff003d7fccfa768441e19ac97">registerType</a> (<a class="el" href="namespacegemfire.html#95f7cac0f9954c5b0ed2deb8ca5273ef">TypeFactoryMethod</a> creationFunction)</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6f6f50ae157f68846d046837d91b4726"></a><!-- doxytag: member="gemfire::CacheableEnum::~CacheableEnum" ref="6f6f50ae157f68846d046837d91b4726" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gemfire::CacheableEnum::~CacheableEnum           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e4a5fe0956a7ec2c6d820d06b1646162"></a><!-- doxytag: member="gemfire::CacheableEnum::classId" ref="e4a5fe0956a7ec2c6d820d06b1646162" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t gemfire::CacheableEnum::classId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the classId of the instance being serialized. This is used by deserialization to determine what instance type to create and deserialize into. 
<p>Implements <a class="el" href="classgemfire_1_1Serializable.html#44b62ffe7bfb48ad7a8bd6a56b3d89aa">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="07cf1fa0052048288475d2037962fbaf"></a><!-- doxytag: member="gemfire::CacheableEnum::create" ref="07cf1fa0052048288475d2037962fbaf" args="(const PRIM value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PRIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> gemfire::CacheableKey::create           </td>
          <td>(</td>
          <td class="paramtype">const PRIM&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory method that creates the key type that matches the type of value. 
<p>
For customer defined derivations of <a class="el" href="classgemfire_1_1CacheableKey.html" title="Represents a cacheable key.">CacheableKey</a>, the method gemfire::createKey may be overloaded. For pointer types (e.g. char*) the method <a class="el" href="namespacegemfire.html#591affc2f9cbde8f5e85a675891a859d" title="overload of gemfire::createKeyArr to pass char*">gemfire::createKeyArr</a> may be overloaded. 
<p>Reimplemented from <a class="el" href="classgemfire_1_1Serializable.html#932d6a07ed307cbafd8caf216511fca1">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="7eb680fe8ba2e2fc055c3ae866e6d60a"></a><!-- doxytag: member="gemfire::CacheableEnum::create" ref="7eb680fe8ba2e2fc055c3ae866e6d60a" args="(const char *enumClassName, const char *enumName, int32_t ordinal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableEnumPtr</a> gemfire::CacheableEnum::create           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>enumClassName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>enumName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>ordinal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory method for creating an instance of <a class="el" href="classgemfire_1_1CacheableEnum.html" title="Since C++ enums cannot be directly passed as a parameter to PdxWriter&#39;s writeObject...">CacheableEnum</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>className</em>&nbsp;</td><td>the name of the enum class that maps to the java enum type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enumName</em>&nbsp;</td><td>the name of the enum constant that maps to the java enum type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ordinal</em>&nbsp;</td><td>the ordinal value of the enum constant that maps to the java enum type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classgemfire_1_1CacheableEnum.html">CacheableEnum</a> representing C++ enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="65ea21a3e9feb8498f4aa2bf03732c10"></a><!-- doxytag: member="gemfire::CacheableEnum::createDeserializable" ref="65ea21a3e9feb8498f4aa2bf03732c10" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgemfire_1_1Serializable.html">Serializable</a>* gemfire::CacheableEnum::createDeserializable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creation function for enum. 
</div>
</div><p>
<a class="anchor" name="1f9643ad4a462b08ad2c3145db09e1e1"></a><!-- doxytag: member="gemfire::CacheableEnum::DSFID" ref="1f9643ad4a462b08ad2c3145db09e1e1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int8_t gemfire::Serializable::DSFID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return the Data Serialization Fixed ID type. This is used to determine what instance type to create and deserialize into.<p>
Note that this should not be overridden by custom implementations and is reserved only for builtin types. 
<p>Reimplemented in <a class="el" href="classgemfire_1_1CacheableUndefined.html#87bfb286a44d794333bb4203d8e747d0">gemfire::CacheableUndefined</a>, and <a class="el" href="classgemfire_1_1Struct.html#9a587084f32aa690844f309b94f918b2">gemfire::Struct</a>.</p>

</div>
</div><p>
<a class="anchor" name="bb944671e37541d9aafeb1bcad8b0f1f"></a><!-- doxytag: member="gemfire::CacheableEnum::fromData" ref="bb944671e37541d9aafeb1bcad8b0f1f" args="(DataInput &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1Serializable.html">Serializable</a>* gemfire::CacheableEnum::fromData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1DataInput.html">DataInput</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
deserialize this object 
<p>Implements <a class="el" href="classgemfire_1_1Serializable.html#5daea5047c75864e3c95917c2c33d9f9">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="8c34881d6b1ab6d32c3495130db4013e"></a><!-- doxytag: member="gemfire::CacheableEnum::getEnumClassName" ref="8c34881d6b1ab6d32c3495130db4013e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* gemfire::CacheableEnum::getEnumClassName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>enum class name. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="797f7576b815836b671b3a05cb952868"></a><!-- doxytag: member="gemfire::CacheableEnum::getEnumName" ref="797f7576b815836b671b3a05cb952868" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* gemfire::CacheableEnum::getEnumName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>enum name. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="cb43a4094f6ffb71fa507257a8a063af"></a><!-- doxytag: member="gemfire::CacheableEnum::getEnumOrdinal" ref="cb43a4094f6ffb71fa507257a8a063af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t gemfire::CacheableEnum::getEnumOrdinal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>enum ordinal. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="05e2210bc53683348cd3919abecdebe7"></a><!-- doxytag: member="gemfire::CacheableEnum::hashcode" ref="05e2210bc53683348cd3919abecdebe7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t gemfire::CacheableEnum::hashcode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the hashcode for this key. </dd></dl>

<p>

<p>Implements <a class="el" href="classgemfire_1_1CacheableKey.html#f2132b4d37973d8a9a86617ca302663d">gemfire::CacheableKey</a>.</p>

</div>
</div><p>
<a class="anchor" name="6449a06bf4d92683cda94330f657c9f2"></a><!-- doxytag: member="gemfire::CacheableEnum::logString" ref="6449a06bf4d92683cda94330f657c9f2" args="(char *buffer, int32_t maxLength) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t gemfire::CacheableKey::logString           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the string form of a key into a char* buffer for logging purposes. 
<p>
Implementations should only generate a string as long as maxLength chars, and return the number of chars written. buffer is expected to be large enough to hold at least maxLength chars.<p>
The default implementation renders the classname and instance address. 
<p>Reimplemented in <a class="el" href="classgemfire_1_1CacheableKeyType.html#5d0c6c6688fe167c3b5033e8c3a5cb29">gemfire::CacheableKeyType&lt; TObj, TYPEID, TYPENAME, SPRINTFSYM, STRSIZE &gt;</a>, <a class="el" href="classgemfire_1_1CacheableDate.html#27127b0e7ddfd82cbc42a03fb3c12b41">gemfire::CacheableDate</a>, and <a class="el" href="classgemfire_1_1CacheableString.html#2134bffc718c564d167d108a7f4e528f">gemfire::CacheableString</a>.</p>

</div>
</div><p>
<a class="anchor" name="dc3651651a796d7be87e506ff5fdefe2"></a><!-- doxytag: member="gemfire::CacheableEnum::objectSize" ref="dc3651651a796d7be87e506ff5fdefe2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t gemfire::CacheableEnum::objectSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the size of the object in bytes </dd></dl>

<p>

<p>Reimplemented from <a class="el" href="classgemfire_1_1Serializable.html#b0e6e7b2904f127e6cebcbaba628686e">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="1a52cbcbff655cfeb9955ce68e1470d0"></a><!-- doxytag: member="gemfire::CacheableEnum::operator==" ref="1a52cbcbff655cfeb9955ce68e1470d0" args="(const CacheableKey &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::CacheableEnum::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1CacheableKey.html">CacheableKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if this key matches other. </dd></dl>

<p>

<p>Implements <a class="el" href="classgemfire_1_1CacheableKey.html#45c7297332d5d31a04f81e5b62374cd1">gemfire::CacheableKey</a>.</p>

</div>
</div><p>
<a class="anchor" name="327be04b1f16b21a84b654e62c8cb047"></a><!-- doxytag: member="gemfire::CacheableEnum::preserveSB" ref="327be04b1f16b21a84b654e62c8cb047" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::SharedBase::preserveSB           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Atomically increment reference count. 
<p>

</div>
</div><p>
<a class="anchor" name="197c0b015e8fa9656ea520a0fbd57008"></a><!-- doxytag: member="gemfire::CacheableEnum::refCount" ref="197c0b015e8fa9656ea520a0fbd57008" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t gemfire::SharedBase::refCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the reference count </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="850b38d661bf13c9a053f45e2cec0a9f"></a><!-- doxytag: member="gemfire::CacheableEnum::registerPdxSerializer" ref="850b38d661bf13c9a053f45e2cec0a9f" args="(PdxSerializerPtr pdxSerializer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void gemfire::Serializable::registerPdxSerializer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">PdxSerializerPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pdxSerializer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register the PDX serializer which can handle serialization for instances of user domain classes. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PdxSerializer </dd></dl>

</div>
</div><p>
<a class="anchor" name="6a2b0690cd9ce93d14234304073b2ed7"></a><!-- doxytag: member="gemfire::CacheableEnum::registerPdxType" ref="6a2b0690cd9ce93d14234304073b2ed7" args="(TypeFactoryMethodPdx creationFunction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void gemfire::Serializable::registerPdxType           </td>
          <td>(</td>
          <td class="paramtype">TypeFactoryMethodPdx&nbsp;</td>
          <td class="paramname"> <em>creationFunction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
register an Pdx instance factory method for a given type. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the typeName has already been registered, or there is an error in registering the type; check errno for more information in the latter case. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b73c122ff003d7fccfa768441e19ac97"></a><!-- doxytag: member="gemfire::CacheableEnum::registerType" ref="b73c122ff003d7fccfa768441e19ac97" args="(TypeFactoryMethod creationFunction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void gemfire::Serializable::registerType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegemfire.html#95f7cac0f9954c5b0ed2deb8ca5273ef">TypeFactoryMethod</a>&nbsp;</td>
          <td class="paramname"> <em>creationFunction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
register an instance factory method for a given type. During registration the factory will be invoked to extract the typeId to associate with this function. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the typeId has already been registered, or there is an error in registering the type; check errno for more information in the latter case. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="44da117cf90615f1302a5a70b5eb9d91"></a><!-- doxytag: member="gemfire::CacheableEnum::releaseSB" ref="44da117cf90615f1302a5a70b5eb9d91" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::SharedBase::releaseSB           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Atomically decrement reference count, the <a class="el" href="classgemfire_1_1SharedBase.html" title="This abstract base class is the base class of all user objects that have the shared...">SharedBase</a> object is automatically deleted when its reference count goes to zero. 
<p>

</div>
</div><p>
<a class="anchor" name="246038ec85a4d3a375c529e0c14847c0"></a><!-- doxytag: member="gemfire::CacheableEnum::toData" ref="246038ec85a4d3a375c529e0c14847c0" args="(DataOutput &amp;output) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::CacheableEnum::toData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1DataOutput.html">DataOutput</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
serialize this object 
<p>Implements <a class="el" href="classgemfire_1_1Serializable.html#c9d32d74662cf70f14e80ce44afc1bea">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="98690cc2b9fd67d2baf6eb14f36ccf10"></a><!-- doxytag: member="gemfire::CacheableEnum::toString" ref="98690cc2b9fd67d2baf6eb14f36ccf10" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableStringPtr</a> gemfire::CacheableEnum::toString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Display this object as c string. 
<p>

<p>Reimplemented from <a class="el" href="classgemfire_1_1Serializable.html#20418e3d5927a962970d8721bf045af2">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="b30dc6ed8e27ff3525fef477fa44ee44"></a><!-- doxytag: member="gemfire::CacheableEnum::typeId" ref="b30dc6ed8e27ff3525fef477fa44ee44" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int8_t gemfire::CacheableEnum::typeId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return the typeId byte of the instance being serialized. This is used by deserialization to determine what instance type to create and deserialize into. 
<p>Reimplemented from <a class="el" href="classgemfire_1_1Serializable.html#f5069335ab21d323c8fd4510b4f7d51a">gemfire::Serializable</a>.</p>

</div>
</div><p>
<HR><address style="align: right;"><small>GemFire C++ Cache API Documentation</small></address>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Pivotal GemFire Native Client Cache Reference: gemfire::Region Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacegemfire.html">gemfire</a>::<a class="el" href="classgemfire_1_1Region.html">Region</a></div>
<h1>gemfire::Region Class Reference</h1><!-- doxytag: class="gemfire::Region" --><!-- doxytag: inherits="gemfire::SharedBase" -->Inherits <a class="el" href="classgemfire_1_1SharedBase.html">gemfire::SharedBase</a>.
<p>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class manages subregions and cached data. 
<p>
Each region can contain multiple subregions and entries for data. Regions provide a hierachical name space within the cache. Also, a region can be used to group cached objects for management purposes.<p>
Entries managed by the region are key-value pairs. A set of region attributes is associated with the region when it is created.<p>
The <a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a> interface basically contains two set of APIs: <a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a> management APIs and (potentially) distributed operations on entries. Non-distributed operations on entries are provided by <code><a class="el" href="classgemfire_1_1RegionEntry.html" title="An object in a Region that represents an entry, i.e., a key-value pair.">RegionEntry</a></code>.<p>
Each <code><a class="el" href="classgemfire_1_1Cache.html" title="Cache are obtained from create method on the CacheFactory#create class.">Cache</a></code> defines regions called the root regions. User applications can use the root regions to create subregions for isolated name space and object grouping.<p>
A region's name can be any String, except that it should not contain the region name separator, a forward slash (/).<p>
<code>Regions</code> can be referenced by a relative path name from any region higher in the hierarchy in <a class="el" href="classgemfire_1_1Region.html#887300077216513ae9b979ffdab36983">Region::getSubregion</a>. You can get the relative path from the root region with <a class="el" href="classgemfire_1_1Region.html#ecebbbe4138bb8cc1402a44ef319e663">Region::getFullPath</a>. The name separator is used to concatenate all the region names together from the root, starting with the root's subregions.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1RegionAttributes.html" title="Defines attributes for configuring a region.">RegionAttributes</a> </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#d84d7304ac66099bddfcb367e064ac61">clear</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> or <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> invoked in the process.  <a href="#d84d7304ac66099bddfcb367e064ac61"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#66aff51decf9d14d6064d582430e3052">containsKey</a> (const KEYTYPE &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char* This operations checks for the key in the local cache .  <a href="#66aff51decf9d14d6064d582430e3052"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#ad3bd19c7336f937b79596920bf18f64">containsKey</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;keyPtr) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Only the client's cache is searched for the key.  <a href="#ad3bd19c7336f937b79596920bf18f64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#61a219b00864bcf369683b5d50fbad12">containsKeyOnServer</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;keyPtr) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The cache of the server, to which it is connected with, is searched for the key to see if the key is present.  <a href="#61a219b00864bcf369683b5d50fbad12"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#d433bb89c3c8b3a89830f1aa5a61b946">containsValueForKey</a> (const KEYTYPE &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char* This operations checks for the value in the local cache .  <a href="#d433bb89c3c8b3a89830f1aa5a61b946"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#3b010d7bbc5953c4cbda06d27047d75b">containsValueForKey</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;keyPtr) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This operations checks for the value in the local cache .  <a href="#3b010d7bbc5953c4cbda06d27047d75b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#7f00592c4ffe93956f07c65345c0d36c">create</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#7f00592c4ffe93956f07c65345c0d36c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#825a87ad01baa6aa96cac0abb62f2f0b">create</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#825a87ad01baa6aa96cac0abb62f2f0b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE, class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#23d9d7c5018efe4a34d2ea2659193930">create</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#23d9d7c5018efe4a34d2ea2659193930"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#ecb3c05a5fa94a1950a9fb2cb90ec5eb">create</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new entry in this region with the specified key and value, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#ecb3c05a5fa94a1950a9fb2cb90ec5eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#4b66d56b2d0074be11e82c877fbd2180">createSubregion</a> (const char *subregionName, const <a class="el" href="classgemfire_1_1SharedPtr.html">RegionAttributesPtr</a> &amp;aRegionAttributes)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a subregion with the specified attributes.  <a href="#4b66d56b2d0074be11e82c877fbd2180"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#7aa713cdf523570f804f03cf3cf6fdc4">destroy</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#7aa713cdf523570f804f03cf3cf6fdc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#41dd235083a3f598869ff5331a2b194e">destroy</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys the entry with the specified key, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#41dd235083a3f598869ff5331a2b194e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#2b07a940ee17e375c45421e85b27a8ff">destroyRegion</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#2b07a940ee17e375c45421e85b27a8ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#70a6aca22412dc1e5ea1645866d4ed3d">existsValue</a> (const char *predicate, uint32_t timeout=DEFAULT_QUERY_RESPONSE_TIMEOUT)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the query on the server based on the predicate and returns whether any result exists.  <a href="#70a6aca22412dc1e5ea1645866d4ed3d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#3fc9e58e50952f5be3c5c297e1fd9adb">get</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;callbackArg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#3fc9e58e50952f5be3c5c297e1fd9adb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#6417a042b32bba4bd39011dc5909f4c1">get</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value associated with the specified key, passing the callback argument to any cache loaders that are invoked in the operation.  <a href="#6417a042b32bba4bd39011dc5909f4c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#a830e50c9aac4709fd71d1b7321686d0">getAll</a> (const <a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;keys, <a class="el" href="classgemfire_1_1SharedPtr.html">HashMapOfCacheablePtr</a> values, <a class="el" href="classgemfire_1_1SharedPtr.html">HashMapOfExceptionPtr</a> exceptions, bool addToLocalCache=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets values for an array of keys from the local cache or server.  <a href="#a830e50c9aac4709fd71d1b7321686d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classgemfire_1_1SharedPtr.html">RegionAttributesPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#9fb4c927e07209777c7b9e0c30c960dc">getAttributes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="classgemfire_1_1RegionAttributes.html" title="Defines attributes for configuring a region.">RegionAttributes</a> for this region.  <a href="#9fb4c927e07209777c7b9e0c30c960dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classgemfire_1_1SharedPtr.html">AttributesMutatorPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#060f63b4dbce922eb670b74247860f3a">getAttributesMutator</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the a mutator object for changing a subset of the region attributes.  <a href="#060f63b4dbce922eb670b74247860f3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">CachePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#59e2b8a61d143d6b5176c9aa81178c14">getCache</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <code>cache</code> associated with this region.  <a href="#59e2b8a61d143d6b5176c9aa81178c14"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classgemfire_1_1SharedPtr.html">RegionEntryPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#cb584ce0a2aa2fcaaa156b6313a714b1">getEntry</a> (const KEYTYPE &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#cb584ce0a2aa2fcaaa156b6313a714b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionEntryPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#7cfcd52da8cca9eb076b13846f07ff4e">getEntry</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the meta-object <a class="el" href="classgemfire_1_1RegionEntry.html" title="An object in a Region that represents an entry, i.e., a key-value pair.">RegionEntry</a> for key.  <a href="#7cfcd52da8cca9eb076b13846f07ff4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#ecebbbe4138bb8cc1402a44ef319e663">getFullPath</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the full path of the region as can be used to lookup the region from <a class="el" href="classgemfire_1_1Cache.html#41b57e2c8d0cb54bcee5366710eb759c" title="Look up a region with the full path from root.">Cache::getRegion</a>.  <a href="#ecebbbe4138bb8cc1402a44ef319e663"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#810a07cc9af61c82717c2498fb4a8e17">getInterestList</a> (<a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;vlist) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the list of keys on which this client is interested and will be notified of changes.  <a href="#810a07cc9af61c82717c2498fb4a8e17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#1fc20af32fc83333f321d3725d5db85c">getInterestListRegex</a> (<a class="el" href="classgemfire_1_1VectorT.html">VectorOfCacheableString</a> &amp;vregex) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the list of regular expresssions on which this client is interested and will be notified of changes.  <a href="#1fc20af32fc83333f321d3725d5db85c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#94b993b0c0c172a38ce7a03a07dd90b1">getName</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#aa71bb739cc61375c00c64cff43be34f">getParentRegion</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the parent region, or NULLPTR if a root region.  <a href="#aa71bb739cc61375c00c64cff43be34f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionServicePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#7a7ac0d60050a05da90a911b567fe800">getRegionService</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <code>cache</code> associated with this region.  <a href="#7a7ac0d60050a05da90a911b567fe800"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#887300077216513ae9b979ffdab36983">getSubregion</a> (const char *path)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the subregion identified by the path, NULLPTR if no such subregion.  <a href="#887300077216513ae9b979ffdab36983"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#0719a580a883a5125a60863298e8a20a">invalidate</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#0719a580a883a5125a60863298e8a20a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#695d2a7870358c69d28c3855aa3d7b7f">invalidate</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalidates the entry with the specified key, and provides a user-defined argument to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>.  <a href="#695d2a7870358c69d28c3855aa3d7b7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#fff62eed9d631e53efcb703d6ffd5789">invalidateRegion</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalidates this region.  <a href="#fff62eed9d631e53efcb703d6ffd5789"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#d49244bb426dd2d2aa7443e5fed8e229">keys</a> (<a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;v)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return all the keys in the local process for this region.  <a href="#d49244bb426dd2d2aa7443e5fed8e229"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#29bdbee2d679e08b57c464b1eb652a96">localClear</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> or <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> invoked in the process.  <a href="#29bdbee2d679e08b57c464b1eb652a96"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#4362432c15b1253ca5a9ce181f4e12f9">localCreate</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#4362432c15b1253ca5a9ce181f4e12f9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#62bd67e3c3ecb1a802cfdb456e4f1cc7">localCreate</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#62bd67e3c3ecb1a802cfdb456e4f1cc7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE, class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#52b6e3b8694b961c62a85ef4712208ce">localCreate</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#52b6e3b8694b961c62a85ef4712208ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#7c32c65195cf7fb1825536b8e3239f7b">localCreate</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new entry in this region with the specified key and value in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#7c32c65195cf7fb1825536b8e3239f7b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#83a1243d7c3861882a298a731d06fbc4">localDestroy</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#83a1243d7c3861882a298a731d06fbc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#88f6d0138450902a0e3cba228edbd48a">localDestroy</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#88f6d0138450902a0e3cba228edbd48a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#4ad8b7c842587d3a463bc6f42de13e0d">localDestroyRegion</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#4ad8b7c842587d3a463bc6f42de13e0d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#1341301b604a76dc6f6ef0389f73245d">localInvalidate</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#1341301b604a76dc6f6ef0389f73245d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#6fd95f37c13a7cc49f5725feb782ba8c">localInvalidate</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalidates the entry with the specified key in the local cache only, and provides a user-defined argument to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>.  <a href="#6fd95f37c13a7cc49f5725feb782ba8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#f033850fdf85930b496ee41d306e0b19">localInvalidateRegion</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalidates this region.  <a href="#f033850fdf85930b496ee41d306e0b19"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#5c5551984a07f73600342a9203df25ad">localPut</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#5c5551984a07f73600342a9203df25ad"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#d7690eed69ec01c3c531d2bb332fce83">localPut</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#d7690eed69ec01c3c531d2bb332fce83"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE, class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#fe48179fb849c7c0c8ea1788b3cdcf7e">localPut</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#fe48179fb849c7c0c8ea1788b3cdcf7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#b4326132930e9222a31ad9a1f56f1e5a">localPut</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Places a new value into an entry in this region with the specified key in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#b4326132930e9222a31ad9a1f56f1e5a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#2a54d33c421d31157e8ec0ff5f084bc3">localRemove</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#2a54d33c421d31157e8ec0ff5f084bc3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#6646981a25e78e94711a7f3b5d0262b8">localRemove</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#6646981a25e78e94711a7f3b5d0262b8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE, class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#c3e9cad2d310c0ca988c85748a188f2e">localRemove</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#c3e9cad2d310c0ca988c85748a188f2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#ae5cd3bd2243440983f3fba8daed2aaa">localRemove</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the entry with the specified key and value in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#ae5cd3bd2243440983f3fba8daed2aaa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#0cae547c46ec31a6a8025942471a0da9">localRemoveEx</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#0cae547c46ec31a6a8025942471a0da9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#53889ab65787669cc437066f4199000f">localRemoveEx</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#53889ab65787669cc437066f4199000f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#327be04b1f16b21a84b654e62c8cb047">preserveSB</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically increment reference count.  <a href="#327be04b1f16b21a84b654e62c8cb047"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#c0fcd3a43704025707e5d9f4cc6b752d">put</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#c0fcd3a43704025707e5d9f4cc6b752d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#d8ad13b0711165183a0eed02940c2118">put</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#d8ad13b0711165183a0eed02940c2118"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE, class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#c98c887a28935cdc21dc5218defe765b">put</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#c98c887a28935cdc21dc5218defe765b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#ca7c7bf2eb5d466fa3f5dfa6f9b8d392">put</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Places a new value into an entry in this region with the specified key, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#ca7c7bf2eb5d466fa3f5dfa6f9b8d392"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#3eb6baf3aa4b58bfa810cb1ee6d76bec">putAll</a> (const <a class="el" href="classgemfire_1_1HashMapOfCacheable.html">HashMapOfCacheable</a> &amp;map, uint32_t timeout=15)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Places a set of new values in this region with the specified keys given as a map of key/value pairs.  <a href="#3eb6baf3aa4b58bfa810cb1ee6d76bec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">SelectResultsPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#60c3e653c2b6634a2a27de668cf3f7d0">query</a> (const char *predicate, uint32_t timeout=DEFAULT_QUERY_RESPONSE_TIMEOUT)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the query on the server based on the predicate.  <a href="#60c3e653c2b6634a2a27de668cf3f7d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#197c0b015e8fa9656ea520a0fbd57008">refCount</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the reference count </dd></dl>
 <a href="#197c0b015e8fa9656ea520a0fbd57008"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#40219e26a13978054c203024af365f71">registerAllKeys</a> (bool isDurable=false, <a class="el" href="classgemfire_1_1SharedPtr.html">VectorOfCacheableKeyPtr</a> resultKeys=gemfire::NullSharedBase::s_instancePtr, bool getInitialValues=false, bool receiveValues=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers to get updates for all keys from the server.  <a href="#40219e26a13978054c203024af365f71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#c068483783251bdcbedb3e4f7e5071dd">registerKeys</a> (const <a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;keys, bool isDurable=false, bool getInitialValues=false, bool receiveValues=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers an array of keys for getting updates from the server.  <a href="#c068483783251bdcbedb3e4f7e5071dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#bd438bc24e6007094a3833c7ddf7cab4">registerRegex</a> (const char *regex, bool isDurable=false, <a class="el" href="classgemfire_1_1SharedPtr.html">VectorOfCacheableKeyPtr</a> resultKeys=gemfire::NullSharedBase::s_instancePtr, bool getInitialValues=false, bool receiveValues=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a regular expression to match with keys to get updates from the server.  <a href="#bd438bc24e6007094a3833c7ddf7cab4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#44da117cf90615f1302a5a70b5eb9d91">releaseSB</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically decrement reference count, the <a class="el" href="classgemfire_1_1SharedBase.html" title="This abstract base class is the base class of all user objects that have the shared...">SharedBase</a> object is automatically deleted when its reference count goes to zero.  <a href="#44da117cf90615f1302a5a70b5eb9d91"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#c7d1e03ec5bc779b9a804e1d79ac8e97">remove</a> (const KEYTYPE &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#c7d1e03ec5bc779b9a804e1d79ac8e97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#20f94c1a05b5c3a551b9c4260f1929d7">remove</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#20f94c1a05b5c3a551b9c4260f1929d7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#e2913146bd0dfe2e9161255b80547c1d">remove</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#e2913146bd0dfe2e9161255b80547c1d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE, class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#af1ff11eb93fb50447625974f25df7ea">remove</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#af1ff11eb93fb50447625974f25df7ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#759e15064bcccf16e898a8de8502851e">remove</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the entry with the specified key, value and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#759e15064bcccf16e898a8de8502851e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class KEYTYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#81b648d0795965776bc69c02da655e12">removeEx</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#81b648d0795965776bc69c02da655e12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#5c49ed8cd8ed88625ccad3791416590c">removeEx</a> (const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the entry with the specified key and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process.  <a href="#5c49ed8cd8ed88625ccad3791416590c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#2aed8c623fb3cec5e5574348c268e581">selectValue</a> (const char *predicate, uint32_t timeout=DEFAULT_QUERY_RESPONSE_TIMEOUT)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the query on the server based on the predicate and returns a single result value.  <a href="#2aed8c623fb3cec5e5574348c268e581"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#b0429277fb24eb3e7401dae91a699155">serverKeys</a> (<a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;v)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the set of keys defined in the server process associated to this client and region.  <a href="#b0429277fb24eb3e7401dae91a699155"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#5936a627a93153f6d6be7af1c41a4b49">size</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of region.  <a href="#5936a627a93153f6d6be7af1c41a4b49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#aad82433371c15d619b88baa8b35903e">subregions</a> (const bool recursive, <a class="el" href="classgemfire_1_1VectorT.html">VectorOfRegion</a> &amp;sr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Populates the passed in VectorOfRegion with subregions of the current region.  <a href="#aad82433371c15d619b88baa8b35903e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#93608329f29a824fa78fa0ecc20de9b6">unregisterAllKeys</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers to get updates for all keys from the server.  <a href="#93608329f29a824fa78fa0ecc20de9b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#2ed1c18d8b7ed87f89a26e8199b09f32">unregisterKeys</a> (const <a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;keys)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters an array of keys to stop getting updates for them.  <a href="#2ed1c18d8b7ed87f89a26e8199b09f32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#21fdcf25dc377ca43544ee1cacd241cd">unregisterRegex</a> (const char *regex)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters a regular expression to stop getting updates for keys from the server.  <a href="#21fdcf25dc377ca43544ee1cacd241cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Region.html#7d25cce2f2fcff0ba37e3f8f43c345b1">values</a> (<a class="el" href="classgemfire_1_1VectorOfCacheable.html">VectorOfCacheable</a> &amp;vc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return all values in the local process for this region.  <a href="#7d25cce2f2fcff0ba37e3f8f43c345b1"></a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d84d7304ac66099bddfcb367e064ac61"></a><!-- doxytag: member="gemfire::Region::clear" ref="d84d7304ac66099bddfcb367e064ac61" args="(const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::clear           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> or <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> invoked in the process. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1CacheListener.html#6d3950520d80578a3bcd1d142b4ec094" title="Handles the event of a region being cleared.">CacheListener::afterRegionClear</a> <p>
CacheWriter::beforeRegionClear </dd></dl>

</div>
</div><p>
<a class="anchor" name="66aff51decf9d14d6064d582430e3052"></a><!-- doxytag: member="gemfire::Region::containsKey" ref="66aff51decf9d14d6064d582430e3052" args="(const KEYTYPE &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::containsKey           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char* This operations checks for the key in the local cache . 
<p>
It is not propagated to the Gemfire cache server to which it is connected. 
</div>
</div><p>
<a class="anchor" name="ad3bd19c7336f937b79596920bf18f64"></a><!-- doxytag: member="gemfire::Region::containsKey" ref="ad3bd19c7336f937b79596920bf18f64" args="(const CacheableKeyPtr &amp;keyPtr) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::containsKey           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keyPtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only the client's cache is searched for the key. 
<p>
It does not go to the java server to which it is connected with. 
</div>
</div><p>
<a class="anchor" name="61a219b00864bcf369683b5d50fbad12"></a><!-- doxytag: member="gemfire::Region::containsKeyOnServer" ref="61a219b00864bcf369683b5d50fbad12" args="(const CacheableKeyPtr &amp;keyPtr) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::containsKeyOnServer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keyPtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The cache of the server, to which it is connected with, is searched for the key to see if the key is present. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>if the region's scope is <a class="el" href="classgemfire_1_1ScopeType.html#a30074e46fcb3e571974f60fe95a495a78b77e65de9646e73d76291bc9087751" title="no distribution.">ScopeType::LOCAL</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d433bb89c3c8b3a89830f1aa5a61b946"></a><!-- doxytag: member="gemfire::Region::containsValueForKey" ref="d433bb89c3c8b3a89830f1aa5a61b946" args="(const KEYTYPE &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::containsValueForKey           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char* This operations checks for the value in the local cache . 
<p>
It is not propagated to the Gemfire cache server to which it is connected. 
</div>
</div><p>
<a class="anchor" name="3b010d7bbc5953c4cbda06d27047d75b"></a><!-- doxytag: member="gemfire::Region::containsValueForKey" ref="3b010d7bbc5953c4cbda06d27047d75b" args="(const CacheableKeyPtr &amp;keyPtr) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::containsValueForKey           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keyPtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operations checks for the value in the local cache . 
<p>
It is not propagated to the Gemfire cache server to which it is connected. 
</div>
</div><p>
<a class="anchor" name="7f00592c4ffe93956f07c65345c0d36c"></a><!-- doxytag: member="gemfire::Region::create" ref="7f00592c4ffe93956f07c65345c0d36c" args="(const CacheableKeyPtr &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="825a87ad01baa6aa96cac0abb62f2f0b"></a><!-- doxytag: member="gemfire::Region::create" ref="825a87ad01baa6aa96cac0abb62f2f0b" args="(const KEYTYPE &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::create           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="23d9d7c5018efe4a34d2ea2659193930"></a><!-- doxytag: member="gemfire::Region::create" ref="23d9d7c5018efe4a34d2ea2659193930" args="(const KEYTYPE &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE, class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::create           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing both key and value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="ecb3c05a5fa94a1950a9fb2cb90ec5eb"></a><!-- doxytag: member="gemfire::Region::create" ref="ecb3c05a5fa94a1950a9fb2cb90ec5eb" args="(const CacheableKeyPtr &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new entry in this region with the specified key and value, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. The new entry is propogated to the java server also to which it is connected with. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. <p>
If remote server put fails throwing back a <code>CacheServerException</code> or security exception, then local put is tried to rollback. However, if the entry has overflowed/evicted/expired then the rollback is aborted since it may be due to a more recent notification or update by another thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key smart pointer for which to create the entry in this region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the value for the new entry, which may be NULLPTR meaning the new entry starts as if it had been locally invalidated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. Should be serializable if passed to remote callback events </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key is NULLPTR or if the key, value, or aCallbackArgument do not meet serializability requirements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if region is no longer valid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. Only for Native Client regions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if the operation timed out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutOfMemoryException</em>&nbsp;</td><td>if no memory for new entry </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EntryExistsException</em>&nbsp;</td><td>if an entry with this key already exists </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4b66d56b2d0074be11e82c877fbd2180"></a><!-- doxytag: member="gemfire::Region::createSubregion" ref="4b66d56b2d0074be11e82c877fbd2180" args="(const char *subregionName, const RegionAttributesPtr &amp;aRegionAttributes)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionPtr</a> gemfire::Region::createSubregion           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>subregionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">RegionAttributesPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aRegionAttributes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a subregion with the specified attributes. 
<p>

</div>
</div><p>
<a class="anchor" name="7aa713cdf523570f804f03cf3cf6fdc4"></a><!-- doxytag: member="gemfire::Region::destroy" ref="7aa713cdf523570f804f03cf3cf6fdc4" args="(const KEYTYPE &amp;key, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::destroy           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="41dd235083a3f598869ff5331a2b194e"></a><!-- doxytag: member="gemfire::Region::destroy" ref="41dd235083a3f598869ff5331a2b194e" args="(const CacheableKeyPtr &amp;key, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::destroy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the entry with the specified key, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. Destroy removes not only the value, but also the key and entry from this region.<p>
The destroy is propogated to the Gemfire cache server to which it is connected with. If the destroy fails due to an exception on server throwing back <code>CacheServerException</code> or security exception, then the local entry is still destroyed.<p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key of the entry to destroy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Gemfire cache server. Only for Native Client regions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if the operation timed out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if the region is destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EntryNotFoundException</em>&nbsp;</td><td>if the entry does not exist in this region. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#695d2a7870358c69d28c3855aa3d7b7f" title="Invalidates the entry with the specified key, and provides a user-defined argument...">invalidate</a> <p>
<a class="el" href="classgemfire_1_1CacheListener.html#3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> <p>
<a class="el" href="classgemfire_1_1CacheWriter.html#73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b07a940ee17e375c45421e85b27a8ff"></a><!-- doxytag: member="gemfire::Region::destroyRegion" ref="2b07a940ee17e375c45421e85b27a8ff" args="(const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::destroyRegion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
Destroy cascades to all entries and subregions. After the destroy, this region object cannot be used any more. Any attempt to use this region object will get a <code>RegionDestroyedException</code> exception.<p>
The region destroy not only destroys the local region but also destroys the server region. However, if server region destroy fails throwing back <code>CacheServerException</code> or security exception, the local region is still destroyed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this call. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation; if this occurs some subregions may have already been successfully destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. Only for Native Client regions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if not connected to the <a class="el" href="namespacegemfire.html" title="This namespace contains all the GemFire C++ API classes, enumerations and globals...">gemfire</a> system because the client cannot establish usable connections to any of the servers given to it. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#fff62eed9d631e53efcb703d6ffd5789" title="Invalidates this region.">invalidateRegion</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="70a6aca22412dc1e5ea1645866d4ed3d"></a><!-- doxytag: member="gemfire::Region::existsValue" ref="70a6aca22412dc1e5ea1645866d4ed3d" args="(const char *predicate, uint32_t timeout=DEFAULT_QUERY_RESPONSE_TIMEOUT)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::existsValue           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>DEFAULT_QUERY_RESPONSE_TIMEOUT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes the query on the server based on the predicate and returns whether any result exists. 
<p>
Valid only for a Native Client region. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>predicate</em>&nbsp;</td><td>The query predicate (just the WHERE clause) or the entire query to execute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The time (in seconds) to wait for the response, optional. This should be less than or equal to 2^31/1000 i.e. 2147483. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>If predicate is empty or timeout parameter is greater than 2^31/1000. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>QueryException</em>&nbsp;</td><td>if some query error occurred at the server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if a server connection error occurs. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when the reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheClosedException</em>&nbsp;</td><td>if the cache has been closed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the result size is non-zero, false otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3fc9e58e50952f5be3c5c297e1fd9adb"></a><!-- doxytag: member="gemfire::Region::get" ref="3fc9e58e50952f5be3c5c297e1fd9adb" args="(const KEYTYPE &amp;key, const UserDataPtr &amp;callbackArg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> gemfire::Region::get           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callbackArg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="6417a042b32bba4bd39011dc5909f4c1"></a><!-- doxytag: member="gemfire::Region::get" ref="6417a042b32bba4bd39011dc5909f4c1" args="(const CacheableKeyPtr &amp;key, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> gemfire::Region::get           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value associated with the specified key, passing the callback argument to any cache loaders that are invoked in the operation. 
<p>
If the value is not present locally then it is requested from the java server. If even that is unsuccessful then a local <a class="el" href="classgemfire_1_1CacheLoader.html" title="An application plug-in that can be installed on a region.">CacheLoader</a> will be invoked if there is one. The value returned by get is not copied, so multi-threaded applications should not modify the value directly, but should use the update methods. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a>, <a class="el" href="">CacheStatistics::getHitCount</a>, <a class="el" href="">CacheStatistics::getMissCount</a>, and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> (if a new value is loaded) for this region and the entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>whose associated value is to be returned. The key Object must implement the equals and hashCode methods. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>an argument passed into the <a class="el" href="classgemfire_1_1CacheLoader.html" title="An application plug-in that can be installed on a region.">CacheLoader</a> if loader is used. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key is NULLPTR or aCallbackArgument is not serializable and a remote <a class="el" href="classgemfire_1_1CacheLoader.html" title="An application plug-in that can be installed on a region.">CacheLoader</a> needs to be invoked </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheLoaderException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheLoader.html" title="An application plug-in that can be installed on a region.">CacheLoader</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. Only for Native Client regions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if the method is called on a destroyed region </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a830e50c9aac4709fd71d1b7321686d0"></a><!-- doxytag: member="gemfire::Region::getAll" ref="a830e50c9aac4709fd71d1b7321686d0" args="(const VectorOfCacheableKey &amp;keys, HashMapOfCacheablePtr values, HashMapOfExceptionPtr exceptions, bool addToLocalCache=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::getAll           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">HashMapOfCacheablePtr</a>&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">HashMapOfExceptionPtr</a>&nbsp;</td>
          <td class="paramname"> <em>exceptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>addToLocalCache</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets values for an array of keys from the local cache or server. 
<p>
If value for a key is not present locally then it is requested from the java server. The value returned is not copied, so multi-threaded applications should not modify the value directly, but should use the update methods. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a>, <a class="el" href="">CacheStatistics::getHitCount</a> and <a class="el" href="">CacheStatistics::getMissCount</a> for this region and the entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the array of keys </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>Output parameter that provides the map of keys to respective values. It is ignored if NULLPTR, and when NULLPTR then at least the <code>addToLocalCache</code> parameter should be true and caching should be enabled for the region to get values into the region otherwise an <code>IllegalArgumentException</code> is thrown. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exceptions</em>&nbsp;</td><td>Output parameter that provides the map of keys to any exceptions while obtaining the key. It is ignored if NULLPTR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addToLocalCache</em>&nbsp;</td><td>true if the obtained values have also to be added to the local cache</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>If the array of keys is empty. Other invalid case is when the <code>values</code> parameter is NULLPTR, and either <code>addToLocalCache</code> is false or caching is disabled for this region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server while processing the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the given servers For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>If region destroy is pending. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnknownException</em>&nbsp;</td><td>For other exceptions.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#6417a042b32bba4bd39011dc5909f4c1" title="Returns the value associated with the specified key, passing the callback argument...">get</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9fb4c927e07209777c7b9e0c30c960dc"></a><!-- doxytag: member="gemfire::Region::getAttributes" ref="9fb4c927e07209777c7b9e0c30c960dc" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionAttributesPtr</a> gemfire::Region::getAttributes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <a class="el" href="classgemfire_1_1RegionAttributes.html" title="Defines attributes for configuring a region.">RegionAttributes</a> for this region. 
<p>

</div>
</div><p>
<a class="anchor" name="060f63b4dbce922eb670b74247860f3a"></a><!-- doxytag: member="gemfire::Region::getAttributesMutator" ref="060f63b4dbce922eb670b74247860f3a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">AttributesMutatorPtr</a> gemfire::Region::getAttributesMutator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the a mutator object for changing a subset of the region attributes. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException.</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="59e2b8a61d143d6b5176c9aa81178c14"></a><!-- doxytag: member="gemfire::Region::getCache" ref="59e2b8a61d143d6b5176c9aa81178c14" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">CachePtr</a> gemfire::Region::getCache           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the <code>cache</code> associated with this region. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the cache </dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>as of NativeClient 3.5, use <a class="el" href="classgemfire_1_1Region.html#7a7ac0d60050a05da90a911b567fe800">Region#getRegionService</a> instead. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb584ce0a2aa2fcaaa156b6313a714b1"></a><!-- doxytag: member="gemfire::Region::getEntry" ref="cb584ce0a2aa2fcaaa156b6313a714b1" args="(const KEYTYPE &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgemfire_1_1SharedPtr.html">RegionEntryPtr</a> gemfire::Region::getEntry           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="7cfcd52da8cca9eb076b13846f07ff4e"></a><!-- doxytag: member="gemfire::Region::getEntry" ref="7cfcd52da8cca9eb076b13846f07ff4e" args="(const CacheableKeyPtr &amp;key)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionEntryPtr</a> gemfire::Region::getEntry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the meta-object <a class="el" href="classgemfire_1_1RegionEntry.html" title="An object in a Region that represents an entry, i.e., a key-value pair.">RegionEntry</a> for key. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException,RegionDestroyedException.</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ecebbbe4138bb8cc1402a44ef319e663"></a><!-- doxytag: member="gemfire::Region::getFullPath" ref="ecebbbe4138bb8cc1402a44ef319e663" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* gemfire::Region::getFullPath           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return the full path of the region as can be used to lookup the region from <a class="el" href="classgemfire_1_1Cache.html#41b57e2c8d0cb54bcee5366710eb759c" title="Look up a region with the full path from root.">Cache::getRegion</a>. 
<p>
The storage is backed by the region. 
</div>
</div><p>
<a class="anchor" name="810a07cc9af61c82717c2498fb4a8e17"></a><!-- doxytag: member="gemfire::Region::getInterestList" ref="810a07cc9af61c82717c2498fb4a8e17" args="(VectorOfCacheableKey &amp;vlist) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::getInterestList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vlist</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the list of keys on which this client is interested and will be notified of changes. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>if the region's scope is <a class="el" href="classgemfire_1_1ScopeType.html#a30074e46fcb3e571974f60fe95a495a78b77e65de9646e73d76291bc9087751" title="no distribution.">ScopeType::LOCAL</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1fc20af32fc83333f321d3725d5db85c"></a><!-- doxytag: member="gemfire::Region::getInterestListRegex" ref="1fc20af32fc83333f321d3725d5db85c" args="(VectorOfCacheableString &amp;vregex) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::getInterestListRegex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1VectorT.html">VectorOfCacheableString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vregex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the list of regular expresssions on which this client is interested and will be notified of changes. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>if the region's scope is <a class="el" href="classgemfire_1_1ScopeType.html#a30074e46fcb3e571974f60fe95a495a78b77e65de9646e73d76291bc9087751" title="no distribution.">ScopeType::LOCAL</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="94b993b0c0c172a38ce7a03a07dd90b1"></a><!-- doxytag: member="gemfire::Region::getName" ref="94b993b0c0c172a38ce7a03a07dd90b1" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* gemfire::Region::getName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Public Methods return single name of region. The storage is backed by the region. 
</div>
</div><p>
<a class="anchor" name="aa71bb739cc61375c00c64cff43be34f"></a><!-- doxytag: member="gemfire::Region::getParentRegion" ref="aa71bb739cc61375c00c64cff43be34f" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionPtr</a> gemfire::Region::getParentRegion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the parent region, or NULLPTR if a root region. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7a7ac0d60050a05da90a911b567fe800"></a><!-- doxytag: member="gemfire::Region::getRegionService" ref="7a7ac0d60050a05da90a911b567fe800" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionServicePtr</a> gemfire::Region::getRegionService           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the <code>cache</code> associated with this region. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the cache </dd></dl>

</div>
</div><p>
<a class="anchor" name="887300077216513ae9b979ffdab36983"></a><!-- doxytag: member="gemfire::Region::getSubregion" ref="887300077216513ae9b979ffdab36983" args="(const char *path)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">RegionPtr</a> gemfire::Region::getSubregion           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the subregion identified by the path, NULLPTR if no such subregion. 
<p>

</div>
</div><p>
<a class="anchor" name="0719a580a883a5125a60863298e8a20a"></a><!-- doxytag: member="gemfire::Region::invalidate" ref="0719a580a883a5125a60863298e8a20a" args="(const KEYTYPE &amp;key, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::invalidate           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="695d2a7870358c69d28c3855aa3d7b7f"></a><!-- doxytag: member="gemfire::Region::invalidate" ref="695d2a7870358c69d28c3855aa3d7b7f" args="(const CacheableKeyPtr &amp;key, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::invalidate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates the entry with the specified key, and provides a user-defined argument to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>. 
<p>
Invalidate only removes the value from the entry, the key is kept intact. To completely remove the entry, destroy should be used. The invalidate is not propogated to the Gemfire cache server to which it is connected with. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key of the value to be invalidated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. Should be serializable if passed to remote callback events </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EntryNotFoundException</em>&nbsp;</td><td>if this entry does not exist in this region locally </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if the region is destroyed </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter...">destroy</a> <p>
<a class="el" href="classgemfire_1_1CacheListener.html#20d40355842f92cf63c8f64b1bb86aa0" title="Handles the event of an entry&#39;s value being invalidated.">CacheListener::afterInvalidate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fff62eed9d631e53efcb703d6ffd5789"></a><!-- doxytag: member="gemfire::Region::invalidateRegion" ref="fff62eed9d631e53efcb703d6ffd5789" args="(const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::invalidateRegion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates this region. 
<p>
The invalidation will cascade to all the subregions and cached entries. After the <code>invalidateRegion</code> , the region and the entries in it still exist. In order to remove all the entries and the region, <code>destroyRegion</code> should be used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if the region is no longer valid </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#2b07a940ee17e375c45421e85b27a8ff" title="Destroys the whole region and provides a user-defined parameter object to any CacheWriter...">destroyRegion</a> <p>
<a class="el" href="classgemfire_1_1CacheListener.html#d23f60ed056fb03912191092eef29a62" title="Handles the event of a region being invalidated.">CacheListener::afterRegionInvalidate</a> This operation is not distributed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d49244bb426dd2d2aa7443e5fed8e229"></a><!-- doxytag: member="gemfire::Region::keys" ref="d49244bb426dd2d2aa7443e5fed8e229" args="(VectorOfCacheableKey &amp;v)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::keys           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return all the keys in the local process for this region. 
<p>
This includes keys for which the entry is invalid. 
</div>
</div><p>
<a class="anchor" name="29bdbee2d679e08b57c464b1eb652a96"></a><!-- doxytag: member="gemfire::Region::localClear" ref="29bdbee2d679e08b57c464b1eb652a96" args="(const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localClear           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> or <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> invoked in the process. 
<p>
Clear will not be distributed to other caches. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1CacheListener.html#6d3950520d80578a3bcd1d142b4ec094" title="Handles the event of a region being cleared.">CacheListener::afterRegionClear</a> <p>
CacheWriter::beforeRegionClear </dd></dl>

</div>
</div><p>
<a class="anchor" name="4362432c15b1253ca5a9ce181f4e12f9"></a><!-- doxytag: member="gemfire::Region::localCreate" ref="4362432c15b1253ca5a9ce181f4e12f9" args="(const CacheableKeyPtr &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localCreate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="62bd67e3c3ecb1a802cfdb456e4f1cc7"></a><!-- doxytag: member="gemfire::Region::localCreate" ref="62bd67e3c3ecb1a802cfdb456e4f1cc7" args="(const KEYTYPE &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localCreate           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="52b6e3b8694b961c62a85ef4712208ce"></a><!-- doxytag: member="gemfire::Region::localCreate" ref="52b6e3b8694b961c62a85ef4712208ce" args="(const KEYTYPE &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE, class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localCreate           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing both key and value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="7c32c65195cf7fb1825536b8e3239f7b"></a><!-- doxytag: member="gemfire::Region::localCreate" ref="7c32c65195cf7fb1825536b8e3239f7b" args="(const CacheableKeyPtr &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localCreate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new entry in this region with the specified key and value in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key smart pointer for which to create the entry in this region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the value for the new entry, which may be NULLPTR meaning the new entry starts as if it had been locally invalidated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. Should be serializable if passed to remote callback events</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key or value is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if region is no longer valid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutOfMemoryException</em>&nbsp;</td><td>if no memory for new entry </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EntryExistsException</em>&nbsp;</td><td>if an entry with this key already exists </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="83a1243d7c3861882a298a731d06fbc4"></a><!-- doxytag: member="gemfire::Region::localDestroy" ref="83a1243d7c3861882a298a731d06fbc4" args="(const KEYTYPE &amp;key, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localDestroy           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="88f6d0138450902a0e3cba228edbd48a"></a><!-- doxytag: member="gemfire::Region::localDestroy" ref="88f6d0138450902a0e3cba228edbd48a" args="(const CacheableKeyPtr &amp;key, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localDestroy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. Destroy removes not only the value but also the key and entry from this region. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key of the entry to destroy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>the callback for user to pass in, default is NULLPTR. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EntryNotFoundException</em>&nbsp;</td><td>if the entry does not exist in this region locally </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#695d2a7870358c69d28c3855aa3d7b7f" title="Invalidates the entry with the specified key, and provides a user-defined argument...">invalidate</a> <p>
<a class="el" href="classgemfire_1_1CacheListener.html#3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> <p>
<a class="el" href="classgemfire_1_1CacheWriter.html#73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4ad8b7c842587d3a463bc6f42de13e0d"></a><!-- doxytag: member="gemfire::Region::localDestroyRegion" ref="4ad8b7c842587d3a463bc6f42de13e0d" args="(const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localDestroyRegion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
Destroy cascades to all entries and subregions. After the destroy, this region object cannot be used any more. Any attempt to use this region object will get a <code>RegionDestroyedException</code> exception. The region destroy is not distributed to other caches.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this call. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation; if this occurs some subregions may have already been successfully destroyed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#f033850fdf85930b496ee41d306e0b19" title="Invalidates this region.">localInvalidateRegion</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1341301b604a76dc6f6ef0389f73245d"></a><!-- doxytag: member="gemfire::Region::localInvalidate" ref="1341301b604a76dc6f6ef0389f73245d" args="(const KEYTYPE &amp;key, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localInvalidate           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="6fd95f37c13a7cc49f5725feb782ba8c"></a><!-- doxytag: member="gemfire::Region::localInvalidate" ref="6fd95f37c13a7cc49f5725feb782ba8c" args="(const CacheableKeyPtr &amp;key, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localInvalidate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates the entry with the specified key in the local cache only, and provides a user-defined argument to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>. 
<p>
Invalidate only removes the value from the entry, the key is kept intact. To completely remove the entry, destroy should be used. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key of the value to be invalidated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. Should be serializable if passed to remote callback events </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EntryNotFoundException</em>&nbsp;</td><td>if this entry does not exist in this region locally </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if the region is destroyed </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter...">destroy</a> <p>
<a class="el" href="classgemfire_1_1CacheListener.html#20d40355842f92cf63c8f64b1bb86aa0" title="Handles the event of an entry&#39;s value being invalidated.">CacheListener::afterInvalidate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f033850fdf85930b496ee41d306e0b19"></a><!-- doxytag: member="gemfire::Region::localInvalidateRegion" ref="f033850fdf85930b496ee41d306e0b19" args="(const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localInvalidateRegion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates this region. 
<p>
The invalidation will cascade to all the subregions and cached entries. After the <code>invalidateRegion</code> , the region and the entries in it still exist. In order to remove all the entries and the region, <code>destroyRegion</code> should be used. The region invalidate will not be distributed to other caches<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if the region is no longer valid </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#2b07a940ee17e375c45421e85b27a8ff" title="Destroys the whole region and provides a user-defined parameter object to any CacheWriter...">destroyRegion</a> <p>
<a class="el" href="classgemfire_1_1CacheListener.html#d23f60ed056fb03912191092eef29a62" title="Handles the event of a region being invalidated.">CacheListener::afterRegionInvalidate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c5551984a07f73600342a9203df25ad"></a><!-- doxytag: member="gemfire::Region::localPut" ref="5c5551984a07f73600342a9203df25ad" args="(const CacheableKeyPtr &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localPut           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="d7690eed69ec01c3c531d2bb332fce83"></a><!-- doxytag: member="gemfire::Region::localPut" ref="d7690eed69ec01c3c531d2bb332fce83" args="(const KEYTYPE &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localPut           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="fe48179fb849c7c0c8ea1788b3cdcf7e"></a><!-- doxytag: member="gemfire::Region::localPut" ref="fe48179fb849c7c0c8ea1788b3cdcf7e" args="(const KEYTYPE &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE, class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localPut           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing both key and value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="b4326132930e9222a31ad9a1f56f1e5a"></a><!-- doxytag: member="gemfire::Region::localPut" ref="b4326132930e9222a31ad9a1f56f1e5a" args="(const CacheableKeyPtr &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localPut           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Places a new value into an entry in this region with the specified key in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. If there is already an entry associated with the specified key in this region, the entry's previous value is overwritten. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>a key smart pointer associated with the value to be put into this region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the value to be put into the cache </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>an argument that is passed to the callback functions</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key or value is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if region no longer valid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutOfMemoryException</em>&nbsp;</td><td>if not enoough memory for the value </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2a54d33c421d31157e8ec0ff5f084bc3"></a><!-- doxytag: member="gemfire::Region::localRemove" ref="2a54d33c421d31157e8ec0ff5f084bc3" args="(const CacheableKeyPtr &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::localRemove           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="6646981a25e78e94711a7f3b5d0262b8"></a><!-- doxytag: member="gemfire::Region::localRemove" ref="6646981a25e78e94711a7f3b5d0262b8" args="(const KEYTYPE &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::localRemove           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="c3e9cad2d310c0ca988c85748a188f2e"></a><!-- doxytag: member="gemfire::Region::localRemove" ref="c3e9cad2d310c0ca988c85748a188f2e" args="(const KEYTYPE &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE, class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::localRemove           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing both key and value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="ae5cd3bd2243440983f3fba8daed2aaa"></a><!-- doxytag: member="gemfire::Region::localRemove" ref="ae5cd3bd2243440983f3fba8daed2aaa" args="(const CacheableKeyPtr &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::localRemove           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the entry with the specified key and value in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> and <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. Remove removes not only the value but also the key and entry from this region. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key of the entry to remove. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the value of the entry to remove. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>the callback for user to pass in, default is NULLPTR. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter...">destroy</a> <p>
<a class="el" href="classgemfire_1_1CacheListener.html#3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> <p>
<a class="el" href="classgemfire_1_1CacheWriter.html#73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0cae547c46ec31a6a8025942471a0da9"></a><!-- doxytag: member="gemfire::Region::localRemoveEx" ref="0cae547c46ec31a6a8025942471a0da9" args="(const KEYTYPE &amp;key, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::localRemoveEx           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="53889ab65787669cc437066f4199000f"></a><!-- doxytag: member="gemfire::Region::localRemoveEx" ref="53889ab65787669cc437066f4199000f" args="(const CacheableKeyPtr &amp;key, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::localRemoveEx           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> and <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. Remove removes not only the value but also the key and entry from this region. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key of the entry to remove. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>the callback for user to pass in, default is NULLPTR. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter...">destroy</a> <p>
<a class="el" href="classgemfire_1_1CacheListener.html#3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> <p>
<a class="el" href="classgemfire_1_1CacheWriter.html#73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="327be04b1f16b21a84b654e62c8cb047"></a><!-- doxytag: member="gemfire::Region::preserveSB" ref="327be04b1f16b21a84b654e62c8cb047" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::SharedBase::preserveSB           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Atomically increment reference count. 
<p>

</div>
</div><p>
<a class="anchor" name="c0fcd3a43704025707e5d9f4cc6b752d"></a><!-- doxytag: member="gemfire::Region::put" ref="c0fcd3a43704025707e5d9f4cc6b752d" args="(const CacheableKeyPtr &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::put           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="d8ad13b0711165183a0eed02940c2118"></a><!-- doxytag: member="gemfire::Region::put" ref="d8ad13b0711165183a0eed02940c2118" args="(const KEYTYPE &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::put           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="c98c887a28935cdc21dc5218defe765b"></a><!-- doxytag: member="gemfire::Region::put" ref="c98c887a28935cdc21dc5218defe765b" args="(const KEYTYPE &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE, class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::put           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing both key and value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="ca7c7bf2eb5d466fa3f5dfa6f9b8d392"></a><!-- doxytag: member="gemfire::Region::put" ref="ca7c7bf2eb5d466fa3f5dfa6f9b8d392" args="(const CacheableKeyPtr &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::put           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Places a new value into an entry in this region with the specified key, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. If there is already an entry associated with the specified key in this region, the entry's previous value is overwritten. The new put value is propogated to the java server to which it is connected with. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry.<p>
If remote server put fails throwing back a <code>CacheServerException</code> or security exception, then local put is tried to rollback. However, if the entry has overflowed/evicted/expired then the rollback is aborted since it may be due to a more recent notification or update by another thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>a key smart pointer associated with the value to be put into this region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the value to be put into the cache </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>an argument that is passed to the callback function</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key or value is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if region no longer valid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutOfMemoryException</em>&nbsp;</td><td>if not enoough memory for the value </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3eb6baf3aa4b58bfa810cb1ee6d76bec"></a><!-- doxytag: member="gemfire::Region::putAll" ref="3eb6baf3aa4b58bfa810cb1ee6d76bec" args="(const HashMapOfCacheable &amp;map, uint32_t timeout=15)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::putAll           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1HashMapOfCacheable.html">HashMapOfCacheable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>15</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Places a set of new values in this region with the specified keys given as a map of key/value pairs. 
<p>
If there is already an entry associated with a specified key in this region, the entry's previous value is overwritten. <p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map,:</em>&nbsp;</td><td>A hashmap containing key-value pairs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout,:</em>&nbsp;</td><td>The time (in seconds) to wait for the response, optional. This should be less than or equal to 2^31/1000 i.e. 2147483. Default is 15 (seconds). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>If timeout parameter is greater than 2^31/1000, ie 2147483. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="60c3e653c2b6634a2a27de668cf3f7d0"></a><!-- doxytag: member="gemfire::Region::query" ref="60c3e653c2b6634a2a27de668cf3f7d0" args="(const char *predicate, uint32_t timeout=DEFAULT_QUERY_RESPONSE_TIMEOUT)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">SelectResultsPtr</a> gemfire::Region::query           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>DEFAULT_QUERY_RESPONSE_TIMEOUT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes the query on the server based on the predicate. 
<p>
Valid only for a Native Client region.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>predicate</em>&nbsp;</td><td>The query predicate (just the WHERE clause) or the entire query to execute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The time (in seconds) to wait for the query response, optional. This should be less than or equal to 2^31/1000 i.e. 2147483.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>If predicate is empty or timeout parameter is greater than 2^31/1000. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>QueryException</em>&nbsp;</td><td>if some query error occurred at the server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if a server connection error occurs. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheClosedException</em>&nbsp;</td><td>if the cache has been closed</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the <a class="el" href="classgemfire_1_1SelectResults.html" title="A SelectResults is obtained by executing a Query on the server.">SelectResults</a> which can either be a <a class="el" href="classgemfire_1_1ResultSet.html" title="A ResultSet may be obtained after executing a Query which is obtained from a QueryService...">ResultSet</a> or a <a class="el" href="classgemfire_1_1StructSet.html" title="A StructSet may be obtained after executing a Query which is obtained from a QueryService...">StructSet</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="197c0b015e8fa9656ea520a0fbd57008"></a><!-- doxytag: member="gemfire::Region::refCount" ref="197c0b015e8fa9656ea520a0fbd57008" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t gemfire::SharedBase::refCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the reference count </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="40219e26a13978054c203024af365f71"></a><!-- doxytag: member="gemfire::Region::registerAllKeys" ref="40219e26a13978054c203024af365f71" args="(bool isDurable=false, VectorOfCacheableKeyPtr resultKeys=gemfire::NullSharedBase::s_instancePtr, bool getInitialValues=false, bool receiveValues=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::registerAllKeys           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isDurable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">VectorOfCacheableKeyPtr</a>&nbsp;</td>
          <td class="paramname"> <em>resultKeys</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>getInitialValues</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>receiveValues</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers to get updates for all keys from the server. 
<p>
Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>isDurable</em>&nbsp;</td><td>flag to indicate whether this is a durable registration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resultKeys</em>&nbsp;</td><td>If non-NULLPTR then all the keys on the server that got registered are returned. The vector is cleared at the start to discard any existing keys in the vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>getInitialValues</em>&nbsp;</td><td>true to populate the cache with values of all keys from the server </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>receiveValues</em>&nbsp;</td><td>whether to act like notify-by-subscription is set</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EntryNotFoundException</em>&nbsp;</td><td>If an exception occurs while obtaining values from server after register interest is complete. The actual cause of the exception can be obtained using <code>Exception::getCause</code>. If an application wants to undo the registration on server, or take some other steps for the incomplete cache population then this is the exception that should be caught. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>If region destroy is pending. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnknownException</em>&nbsp;</td><td>For other exceptions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c068483783251bdcbedb3e4f7e5071dd"></a><!-- doxytag: member="gemfire::Region::registerKeys" ref="c068483783251bdcbedb3e4f7e5071dd" args="(const VectorOfCacheableKey &amp;keys, bool isDurable=false, bool getInitialValues=false, bool receiveValues=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::registerKeys           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isDurable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>getInitialValues</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>receiveValues</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers an array of keys for getting updates from the server. 
<p>
Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the array of keys </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isDurable</em>&nbsp;</td><td>flag to indicate whether this is a durable registration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>getInitialValues</em>&nbsp;</td><td>true to populate the cache with values of the keys that were registered on the server </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>receiveValues</em>&nbsp;</td><td>whether to act like notify-by-subscription is set</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>If the array of keys is empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>If already registered interest for all keys. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EntryNotFoundException</em>&nbsp;</td><td>If an exception occurs while obtaining values from server after register interest is complete. The actual cause of the exception can be obtained using <code>Exception::getCause</code>. If an application wants to undo the registration on server, or take some other steps for the incomplete cache population then this is the exception that should be caught. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>If region destroy is pending. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnknownException</em>&nbsp;</td><td>For other exceptions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bd438bc24e6007094a3833c7ddf7cab4"></a><!-- doxytag: member="gemfire::Region::registerRegex" ref="bd438bc24e6007094a3833c7ddf7cab4" args="(const char *regex, bool isDurable=false, VectorOfCacheableKeyPtr resultKeys=gemfire::NullSharedBase::s_instancePtr, bool getInitialValues=false, bool receiveValues=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::registerRegex           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isDurable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">VectorOfCacheableKeyPtr</a>&nbsp;</td>
          <td class="paramname"> <em>resultKeys</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>getInitialValues</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>receiveValues</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a regular expression to match with keys to get updates from the server. 
<p>
Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>regex</em>&nbsp;</td><td>The regular expression string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isDurable</em>&nbsp;</td><td>flag to indicate whether this is a durable registration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resultKeys</em>&nbsp;</td><td>If non-NULLPTR then the keys that match the regular expression on the server are returned. The vector is cleared at the start to discard any existing keys in the vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>getInitialValues</em>&nbsp;</td><td>true to populate the cache with values of the keys that were registered on the server </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>receiveValues</em>&nbsp;</td><td>whether to act like notify-by-subscription is set</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>If regex is empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>If already registered interest for all keys. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EntryNotFoundException</em>&nbsp;</td><td>If an exception occurs while obtaining values from server after register interest is complete. The actual cause of the exception can be obtained using <code>Exception::getCause</code>. If an application wants to undo the registration on server, or take some other steps for the incomplete cache population then this is the exception that should be caught. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>If region destroy is pending. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnknownException</em>&nbsp;</td><td>For other exceptions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="44da117cf90615f1302a5a70b5eb9d91"></a><!-- doxytag: member="gemfire::Region::releaseSB" ref="44da117cf90615f1302a5a70b5eb9d91" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::SharedBase::releaseSB           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Atomically decrement reference count, the <a class="el" href="classgemfire_1_1SharedBase.html" title="This abstract base class is the base class of all user objects that have the shared...">SharedBase</a> object is automatically deleted when its reference count goes to zero. 
<p>

</div>
</div><p>
<a class="anchor" name="c7d1e03ec5bc779b9a804e1d79ac8e97"></a><!-- doxytag: member="gemfire::Region::remove" ref="c7d1e03ec5bc779b9a804e1d79ac8e97" args="(const KEYTYPE &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::remove           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing both key and value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="20f94c1a05b5c3a551b9c4260f1929d7"></a><!-- doxytag: member="gemfire::Region::remove" ref="20f94c1a05b5c3a551b9c4260f1929d7" args="(const CacheableKeyPtr &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::remove           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="e2913146bd0dfe2e9161255b80547c1d"></a><!-- doxytag: member="gemfire::Region::remove" ref="e2913146bd0dfe2e9161255b80547c1d" args="(const KEYTYPE &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::remove           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="af1ff11eb93fb50447625974f25df7ea"></a><!-- doxytag: member="gemfire::Region::remove" ref="af1ff11eb93fb50447625974f25df7ea" args="(const KEYTYPE &amp;key, const VALUETYPE &amp;value, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE, class VALUETYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::remove           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing both key and value to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="759e15064bcccf16e898a8de8502851e"></a><!-- doxytag: member="gemfire::Region::remove" ref="759e15064bcccf16e898a8de8502851e" args="(const CacheableKeyPtr &amp;key, const CacheablePtr &amp;value, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::remove           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheablePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the entry with the specified key, value and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> and <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. remove removes not only the value, but also the key and entry from this region.<p>
The remove is propogated to the Gemfire cache server to which it is connected with. If the destroy fails due to an exception on server throwing back <code>CacheServerException</code> or security exception, then the local entry is still removed.<p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key of the entry to remove </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the value of the key to remove, it can be NULLPTR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Gemfire cache server. Only for Native Client regions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if the operation timed out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if the region is destroyed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter...">destroy</a> <p>
<a class="el" href="classgemfire_1_1CacheListener.html#3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> <p>
<a class="el" href="classgemfire_1_1CacheWriter.html#73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="81b648d0795965776bc69c02da655e12"></a><!-- doxytag: member="gemfire::Region::removeEx" ref="81b648d0795965776bc69c02da655e12" args="(const KEYTYPE &amp;key, const UserDataPtr &amp;arg=gemfire::NullSharedBase::s_instancePtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::removeEx           </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience method allowing key to be a const char*. 
<p>

</div>
</div><p>
<a class="anchor" name="5c49ed8cd8ed88625ccad3791416590c"></a><!-- doxytag: member="gemfire::Region::removeEx" ref="5c49ed8cd8ed88625ccad3791416590c" args="(const CacheableKeyPtr &amp;key, const UserDataPtr &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::removeEx           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableKeyPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1SharedPtr.html">UserDataPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the entry with the specified key and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code> invoked in the process. 
<p>
The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a></code> and <code><a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1Region.html" title="This class manages subregions and cached data.">Region</a></code>, invoked in the process. remove removes not only the value, but also the key and entry from this region.<p>
The remove is propogated to the Gemfire cache server to which it is connected with. If the destroy fails due to an exception on server throwing back <code>CacheServerException</code> or security exception, then the local entry is still removed.<p>
Updates the <a class="el" href="classgemfire_1_1CacheStatistics.html#05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1CacheStatistics.html#e23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key of the entry to remove </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCallbackArgument</em>&nbsp;</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if key is NULLPTR </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheWriterException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheWriter.html" title="An application plug-in that can be installed on the region.">CacheWriter</a> aborts the operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheListenerException</em>&nbsp;</td><td>if <a class="el" href="classgemfire_1_1CacheListener.html" title="An application plug-in that can be installed on a region.">CacheListener</a> throws an exception </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Gemfire cache server. Only for Native Client regions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if the operation timed out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>if the region is destroyed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classgemfire_1_1Region.html#41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter...">destroy</a> <p>
<a class="el" href="classgemfire_1_1CacheListener.html#3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed.">CacheListener::afterDestroy</a> <p>
<a class="el" href="classgemfire_1_1CacheWriter.html#73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed.">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2aed8c623fb3cec5e5574348c268e581"></a><!-- doxytag: member="gemfire::Region::selectValue" ref="2aed8c623fb3cec5e5574348c268e581" args="(const char *predicate, uint32_t timeout=DEFAULT_QUERY_RESPONSE_TIMEOUT)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a> gemfire::Region::selectValue           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>DEFAULT_QUERY_RESPONSE_TIMEOUT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes the query on the server based on the predicate and returns a single result value. 
<p>
Valid only for a Native Client region. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>predicate</em>&nbsp;</td><td>The query predicate (just the WHERE clause) or the entire query to execute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The time (in seconds) to wait for the response, optional. This should be less than or equal to 2^31/1000 i.e. 2147483. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>If predicate is empty or timeout parameter is greater than 2^31/1000. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>QueryException</em>&nbsp;</td><td>if some query error occurred at the server, or more than one result items are available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if a server connection error occurs. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheClosedException</em>&nbsp;</td><td>if the cache has been closed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the single <a class="el" href="classgemfire_1_1ResultSet.html" title="A ResultSet may be obtained after executing a Query which is obtained from a QueryService...">ResultSet</a> or <a class="el" href="classgemfire_1_1StructSet.html" title="A StructSet may be obtained after executing a Query which is obtained from a QueryService...">StructSet</a> item, or NULLPTR of no results are available. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b0429277fb24eb3e7401dae91a699155"></a><!-- doxytag: member="gemfire::Region::serverKeys" ref="b0429277fb24eb3e7401dae91a699155" args="(VectorOfCacheableKey &amp;v)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::serverKeys           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the set of keys defined in the server process associated to this client and region. 
<p>
If a server has the region defined as a mirror, then this will be the entire keyset for the region across all PEER in the distributed system. The vector v will contain only the server keys. Any prior contents in the vector will be removed. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Gemfire cache server. Only for Native Client regions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MessageExcepton</em>&nbsp;</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if there is a timeout getting the keys </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>if the member type is not CLIENT or region is not a native client one. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5936a627a93153f6d6be7af1c41a4b49"></a><!-- doxytag: member="gemfire::Region::size" ref="5936a627a93153f6d6be7af1c41a4b49" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t gemfire::Region::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the size of region. 
<p>
For native client regions, this will give the number of entries in the local cache and not on the servers. 
</div>
</div><p>
<a class="anchor" name="aad82433371c15d619b88baa8b35903e"></a><!-- doxytag: member="gemfire::Region::subregions" ref="aad82433371c15d619b88baa8b35903e" args="(const bool recursive, VectorOfRegion &amp;sr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::subregions           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1VectorT.html">VectorOfRegion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Populates the passed in VectorOfRegion with subregions of the current region. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>recursive</em>&nbsp;</td><td>determines whether the method recursively fills in subregions </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>sr</em>&nbsp;</td><td>subregions </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="93608329f29a824fa78fa0ecc20de9b6"></a><!-- doxytag: member="gemfire::Region::unregisterAllKeys" ref="93608329f29a824fa78fa0ecc20de9b6" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::unregisterAllKeys           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers to get updates for all keys from the server. 
<p>
Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>If not previously registered all keys. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>If region destroy is pending. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnknownException</em>&nbsp;</td><td>For other exceptions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2ed1c18d8b7ed87f89a26e8199b09f32"></a><!-- doxytag: member="gemfire::Region::unregisterKeys" ref="2ed1c18d8b7ed87f89a26e8199b09f32" args="(const VectorOfCacheableKey &amp;keys)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::unregisterKeys           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1VectorOfCacheableKey.html">VectorOfCacheableKey</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keys</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregisters an array of keys to stop getting updates for them. 
<p>
Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the array of keys</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>If the array of keys is empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>If no keys were previously registered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>If region destroy is pending. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnknownException</em>&nbsp;</td><td>For other exceptions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="21fdcf25dc377ca43544ee1cacd241cd"></a><!-- doxytag: member="gemfire::Region::unregisterRegex" ref="21fdcf25dc377ca43544ee1cacd241cd" args="(const char *regex)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::unregisterRegex           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>regex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregisters a regular expression to stop getting updates for keys from the server. 
<p>
Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>regex</em>&nbsp;</td><td>The regular expression string.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>If regex is empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>If not previously registered this regular expression string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnsupportedOperationException</em>&nbsp;</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CacheServerException</em>&nbsp;</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NotConnectedException</em>&nbsp;</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionDestroyedException</em>&nbsp;</td><td>If region destroy is pending. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnknownException</em>&nbsp;</td><td>For other exceptions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeoutException</em>&nbsp;</td><td>if operation timed out </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7d25cce2f2fcff0ba37e3f8f43c345b1"></a><!-- doxytag: member="gemfire::Region::values" ref="7d25cce2f2fcff0ba37e3f8f43c345b1" args="(VectorOfCacheable &amp;vc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::values           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1VectorOfCacheable.html">VectorOfCacheable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return all values in the local process for this region. 
<p>
No value is included for entries that are invalidated. 
</div>
</div><p>
<HR><address style="align: right;"><small>GemFire C++ Cache API Documentation</small></address>

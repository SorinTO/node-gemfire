<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Pivotal GemFire Native Client Cache Reference: gemfire::Struct Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacegemfire.html">gemfire</a>::<a class="el" href="classgemfire_1_1Struct.html">Struct</a></div>
<h1>gemfire::Struct Class Reference</h1><!-- doxytag: class="gemfire::Struct" --><!-- doxytag: inherits="gemfire::Serializable" -->Inherits <a class="el" href="classgemfire_1_1Serializable.html">gemfire::Serializable</a>.
<p>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a> has a <a class="el" href="classgemfire_1_1StructSet.html" title="A StructSet may be obtained after executing a Query which is obtained from a QueryService...">StructSet</a> as its parent. 
<p>
It contains the field values returned after executing a <a class="el" href="classgemfire_1_1Query.html" title="A Query is obtained from a QueryService which in turn is obtained from the Cache...">Query</a> obtained from a <a class="el" href="classgemfire_1_1QueryService.html" title="QueryService is the class obtained from a Cache.">QueryService</a> which in turn is obtained from a <a class="el" href="classgemfire_1_1Cache.html" title="Cache are obtained from create method on the CacheFactory#create class.">Cache</a>. <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#a25514587d63e6a80c48f21bd118a07f">classId</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the classId for internal use.  <a href="#a25514587d63e6a80c48f21bd118a07f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#9a587084f32aa690844f309b94f918b2">DSFID</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the data serializable fixed ID size type for internal use.  <a href="#9a587084f32aa690844f309b94f918b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classgemfire_1_1Serializable.html">Serializable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#43ce946e04b159259ed22fe0e22052ad">fromData</a> (<a class="el" href="classgemfire_1_1DataInput.html">DataInput</a> &amp;input)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deserializes the <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a> object from the <a class="el" href="classgemfire_1_1DataInput.html" title="Provide operations for reading primitive data values, byte arrays, strings, Serializable...">DataInput</a>.  <a href="#43ce946e04b159259ed22fe0e22052ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#8cba85db761f0e46c2d9dcee149eca5a">getFieldName</a> (int32_t index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the field corresponding to the index number in the <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a>.  <a href="#8cba85db761f0e46c2d9dcee149eca5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classgemfire_1_1SharedPtr.html">StructSetPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#dfbc5710d7e02fd853c40f8287d1c7d7">getStructSet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parent <a class="el" href="classgemfire_1_1StructSet.html" title="A StructSet may be obtained after executing a Query which is obtained from a QueryService...">StructSet</a> of this <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a>.  <a href="#dfbc5710d7e02fd853c40f8287d1c7d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#06fe10219935700157ebb915daa053f7">hasNext</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether another field value is available to iterate over in this <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a>.  <a href="#06fe10219935700157ebb915daa053f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#682c182d082d4dcaee9bcc3cf9ec15ea">length</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of field values available.  <a href="#682c182d082d4dcaee9bcc3cf9ec15ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#ed3478052549a5004340928b52d20c05">next</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the next field value item available in this <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a>.  <a href="#ed3478052549a5004340928b52d20c05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#575c840479ba338a12b3ffbacc912214">objectSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">always returns 0  <a href="#575c840479ba338a12b3ffbacc912214"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#5fa5ec3ee0a519eb26f2c4ee739c3898">operator[]</a> (const char *fieldName) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the field value for the given field name.  <a href="#5fa5ec3ee0a519eb26f2c4ee739c3898"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#af55e5d0261db66e3a6a88dc68c86028">operator[]</a> (int32_t index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the field value for the given index number.  <a href="#af55e5d0261db66e3a6a88dc68c86028"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#327be04b1f16b21a84b654e62c8cb047">preserveSB</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically increment reference count.  <a href="#327be04b1f16b21a84b654e62c8cb047"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#197c0b015e8fa9656ea520a0fbd57008">refCount</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>the reference count </dd></dl>
 <a href="#197c0b015e8fa9656ea520a0fbd57008"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1SharedBase.html#44da117cf90615f1302a5a70b5eb9d91">releaseSB</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically decrement reference count, the <a class="el" href="classgemfire_1_1SharedBase.html" title="This abstract base class is the base class of all user objects that have the shared...">SharedBase</a> object is automatically deleted when its reference count goes to zero.  <a href="#44da117cf90615f1302a5a70b5eb9d91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#710b2a5ceacfe8017a0b80b918abc239">Struct</a> (<a class="el" href="classgemfire_1_1StructSet.html">StructSet</a> *ssPtr, <a class="el" href="classgemfire_1_1VectorT.html">VectorT</a>&lt; <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a> &gt; &amp;fieldValues)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor - meant only for internal use.  <a href="#710b2a5ceacfe8017a0b80b918abc239"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#542d1f79893672884de5736a523a3a1b">toData</a> (<a class="el" href="classgemfire_1_1DataOutput.html">DataOutput</a> &amp;output) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serializes this <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a> object.  <a href="#542d1f79893672884de5736a523a3a1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classgemfire_1_1SharedPtr.html">CacheableStringPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Serializable.html#20418e3d5927a962970d8721bf045af2">toString</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display this object as 'string', which depends on the implementation in the subclasses.  <a href="#20418e3d5927a962970d8721bf045af2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#d8e6541f58ee9574177ae635c62faeba">typeId</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the typeId of <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a> class.  <a href="#d8e6541f58ee9574177ae635c62faeba"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class PRIM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Serializable.html#932d6a07ed307cbafd8caf216511fca1">create</a> (const PRIM value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method that creates the <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a> object that matches the type of value.  <a href="#932d6a07ed307cbafd8caf216511fca1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classgemfire_1_1Serializable.html">Serializable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Struct.html#f1750ce6c4be245790b3da6e71f16c9a">createDeserializable</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory function for registration of <code><a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a></code>.  <a href="#f1750ce6c4be245790b3da6e71f16c9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Serializable.html#850b38d661bf13c9a053f45e2cec0a9f">registerPdxSerializer</a> (<a class="el" href="classgemfire_1_1SharedPtr.html">PdxSerializerPtr</a> pdxSerializer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register the PDX serializer which can handle serialization for instances of user domain classes.  <a href="#850b38d661bf13c9a053f45e2cec0a9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Serializable.html#6a2b0690cd9ce93d14234304073b2ed7">registerPdxType</a> (TypeFactoryMethodPdx creationFunction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1Serializable.html#b73c122ff003d7fccfa768441e19ac97">registerType</a> (<a class="el" href="namespacegemfire.html#95f7cac0f9954c5b0ed2deb8ca5273ef">TypeFactoryMethod</a> creationFunction)</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="710b2a5ceacfe8017a0b80b918abc239"></a><!-- doxytag: member="gemfire::Struct::Struct" ref="710b2a5ceacfe8017a0b80b918abc239" args="(StructSet *ssPtr, VectorT&lt; SerializablePtr &gt; &amp;fieldValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gemfire::Struct::Struct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1StructSet.html">StructSet</a> *&nbsp;</td>
          <td class="paramname"> <em>ssPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1VectorT.html">VectorT</a>&lt; <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fieldValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor - meant only for internal use. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a25514587d63e6a80c48f21bd118a07f"></a><!-- doxytag: member="gemfire::Struct::classId" ref="a25514587d63e6a80c48f21bd118a07f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t gemfire::Struct::classId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the classId for internal use. 
<p>

<p>Implements <a class="el" href="classgemfire_1_1Serializable.html#44b62ffe7bfb48ad7a8bd6a56b3d89aa">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="932d6a07ed307cbafd8caf216511fca1"></a><!-- doxytag: member="gemfire::Struct::create" ref="932d6a07ed307cbafd8caf216511fca1" args="(const PRIM value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PRIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a> gemfire::Serializable::create           </td>
          <td>(</td>
          <td class="paramtype">const PRIM&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory method that creates the <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a> object that matches the type of value. 
<p>
For customer defined derivations of <a class="el" href="classgemfire_1_1Serializable.html" title="This abstract base class is the superclass of all user objects in the cache that...">Serializable</a>, the method gemfire::createValue may be overloaded. For pointer types (e.g. char*) the method <a class="el" href="namespacegemfire.html#2e211aeb8176f40ae5b69a64b823ec63" title="overload of gemfire::createValueArr to pass char*">gemfire::createValueArr</a> may be overloaded. 
<p>Reimplemented in <a class="el" href="classgemfire_1_1CacheableKey.html#07cf1fa0052048288475d2037962fbaf">gemfire::CacheableKey</a>.</p>

</div>
</div><p>
<a class="anchor" name="f1750ce6c4be245790b3da6e71f16c9a"></a><!-- doxytag: member="gemfire::Struct::createDeserializable" ref="f1750ce6c4be245790b3da6e71f16c9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgemfire_1_1Serializable.html">Serializable</a>* gemfire::Struct::createDeserializable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory function for registration of <code><a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a></code>. 
<p>

</div>
</div><p>
<a class="anchor" name="9a587084f32aa690844f309b94f918b2"></a><!-- doxytag: member="gemfire::Struct::DSFID" ref="9a587084f32aa690844f309b94f918b2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int8_t gemfire::Struct::DSFID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the data serializable fixed ID size type for internal use. 
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd>GFE 5.7 </dd></dl>

<p>Reimplemented from <a class="el" href="classgemfire_1_1Serializable.html#1f9643ad4a462b08ad2c3145db09e1e1">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="43ce946e04b159259ed22fe0e22052ad"></a><!-- doxytag: member="gemfire::Struct::fromData" ref="43ce946e04b159259ed22fe0e22052ad" args="(DataInput &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1Serializable.html">Serializable</a>* gemfire::Struct::fromData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1DataInput.html">DataInput</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deserializes the <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a> object from the <a class="el" href="classgemfire_1_1DataInput.html" title="Provide operations for reading primitive data values, byte arrays, strings, Serializable...">DataInput</a>. 
<p>
KN: better comment 
<p>Implements <a class="el" href="classgemfire_1_1Serializable.html#5daea5047c75864e3c95917c2c33d9f9">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="8cba85db761f0e46c2d9dcee149eca5a"></a><!-- doxytag: member="gemfire::Struct::getFieldName" ref="8cba85db761f0e46c2d9dcee149eca5a" args="(int32_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* gemfire::Struct::getFieldName           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the field corresponding to the index number in the <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="dfbc5710d7e02fd853c40f8287d1c7d7"></a><!-- doxytag: member="gemfire::Struct::getStructSet" ref="dfbc5710d7e02fd853c40f8287d1c7d7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgemfire_1_1SharedPtr.html">StructSetPtr</a> gemfire::Struct::getStructSet           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the parent <a class="el" href="classgemfire_1_1StructSet.html" title="A StructSet may be obtained after executing a Query which is obtained from a QueryService...">StructSet</a> of this <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the parent <a class="el" href="classgemfire_1_1StructSet.html" title="A StructSet may be obtained after executing a Query which is obtained from a QueryService...">StructSet</a> of this <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="06fe10219935700157ebb915daa053f7"></a><!-- doxytag: member="gemfire::Struct::hasNext" ref="06fe10219935700157ebb915daa053f7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Struct::hasNext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check whether another field value is available to iterate over in this <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if available otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="682c182d082d4dcaee9bcc3cf9ec15ea"></a><!-- doxytag: member="gemfire::Struct::length" ref="682c182d082d4dcaee9bcc3cf9ec15ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t gemfire::Struct::length           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of field values available. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of field values available. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed3478052549a5004340928b52d20c05"></a><!-- doxytag: member="gemfire::Struct::next" ref="ed3478052549a5004340928b52d20c05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a> gemfire::Struct::next           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the next field value item available in this <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the next item in the <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a> or NULLPTR if no more available. </dd></dl>

</div>
</div><p>
<a class="anchor" name="575c840479ba338a12b3ffbacc912214"></a><!-- doxytag: member="gemfire::Struct::objectSize" ref="575c840479ba338a12b3ffbacc912214" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t gemfire::Struct::objectSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
always returns 0 
<p>

<p>Reimplemented from <a class="el" href="classgemfire_1_1Serializable.html#b0e6e7b2904f127e6cebcbaba628686e">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="5fa5ec3ee0a519eb26f2c4ee739c3898"></a><!-- doxytag: member="gemfire::Struct::operator[]" ref="5fa5ec3ee0a519eb26f2c4ee739c3898" args="(const char *fieldName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a> gemfire::Struct::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fieldName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the field value for the given field name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fieldName</em>&nbsp;</td><td>the name of the field whos value is required. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the field value. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalArgumentException</em>&nbsp;</td><td>if the field name is not found. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af55e5d0261db66e3a6a88dc68c86028"></a><!-- doxytag: member="gemfire::Struct::operator[]" ref="af55e5d0261db66e3a6a88dc68c86028" args="(int32_t index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgemfire_1_1SharedPtr.html">SerializablePtr</a> gemfire::Struct::operator[]           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the field value for the given index number. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>the index number of the field value to get. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to the field value or NULLPTR if index out of bounds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="327be04b1f16b21a84b654e62c8cb047"></a><!-- doxytag: member="gemfire::Struct::preserveSB" ref="327be04b1f16b21a84b654e62c8cb047" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::SharedBase::preserveSB           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Atomically increment reference count. 
<p>

</div>
</div><p>
<a class="anchor" name="197c0b015e8fa9656ea520a0fbd57008"></a><!-- doxytag: member="gemfire::Struct::refCount" ref="197c0b015e8fa9656ea520a0fbd57008" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t gemfire::SharedBase::refCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the reference count </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="850b38d661bf13c9a053f45e2cec0a9f"></a><!-- doxytag: member="gemfire::Struct::registerPdxSerializer" ref="850b38d661bf13c9a053f45e2cec0a9f" args="(PdxSerializerPtr pdxSerializer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void gemfire::Serializable::registerPdxSerializer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1SharedPtr.html">PdxSerializerPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pdxSerializer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register the PDX serializer which can handle serialization for instances of user domain classes. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PdxSerializer </dd></dl>

</div>
</div><p>
<a class="anchor" name="6a2b0690cd9ce93d14234304073b2ed7"></a><!-- doxytag: member="gemfire::Struct::registerPdxType" ref="6a2b0690cd9ce93d14234304073b2ed7" args="(TypeFactoryMethodPdx creationFunction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void gemfire::Serializable::registerPdxType           </td>
          <td>(</td>
          <td class="paramtype">TypeFactoryMethodPdx&nbsp;</td>
          <td class="paramname"> <em>creationFunction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
register an Pdx instance factory method for a given type. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the typeName has already been registered, or there is an error in registering the type; check errno for more information in the latter case. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b73c122ff003d7fccfa768441e19ac97"></a><!-- doxytag: member="gemfire::Struct::registerType" ref="b73c122ff003d7fccfa768441e19ac97" args="(TypeFactoryMethod creationFunction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void gemfire::Serializable::registerType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegemfire.html#95f7cac0f9954c5b0ed2deb8ca5273ef">TypeFactoryMethod</a>&nbsp;</td>
          <td class="paramname"> <em>creationFunction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
register an instance factory method for a given type. During registration the factory will be invoked to extract the typeId to associate with this function. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IllegalStateException</em>&nbsp;</td><td>if the typeId has already been registered, or there is an error in registering the type; check errno for more information in the latter case. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="44da117cf90615f1302a5a70b5eb9d91"></a><!-- doxytag: member="gemfire::Struct::releaseSB" ref="44da117cf90615f1302a5a70b5eb9d91" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::SharedBase::releaseSB           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Atomically decrement reference count, the <a class="el" href="classgemfire_1_1SharedBase.html" title="This abstract base class is the base class of all user objects that have the shared...">SharedBase</a> object is automatically deleted when its reference count goes to zero. 
<p>

</div>
</div><p>
<a class="anchor" name="542d1f79893672884de5736a523a3a1b"></a><!-- doxytag: member="gemfire::Struct::toData" ref="542d1f79893672884de5736a523a3a1b" args="(DataOutput &amp;output) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Struct::toData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1DataOutput.html">DataOutput</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Serializes this <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a> object. 
<p>
KN: better comment 
<p>Implements <a class="el" href="classgemfire_1_1Serializable.html#c9d32d74662cf70f14e80ce44afc1bea">gemfire::Serializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="20418e3d5927a962970d8721bf045af2"></a><!-- doxytag: member="gemfire::Struct::toString" ref="20418e3d5927a962970d8721bf045af2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1SharedPtr.html">CacheableStringPtr</a> gemfire::Serializable::toString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Display this object as 'string', which depends on the implementation in the subclasses. 
<p>
The default implementation renders the classname.<p>
The return value may be a temporary, so the caller has to ensure that the <a class="el" href="classgemfire_1_1SharedPtr.html" title="Defines a reference counted shared pointer.">SharedPtr</a> count does not go down to zero by storing the result in a variable or otherwise. 
<p>Reimplemented in <a class="el" href="classgemfire_1_1CacheableKeyType.html#77b12bba2e1e875d81c18e91a2799232">gemfire::CacheableKeyType&lt; TObj, TYPEID, TYPENAME, SPRINTFSYM, STRSIZE &gt;</a>, <a class="el" href="classgemfire_1_1CacheableDate.html#f3b89c7d3203460422c6c2dcb3b61115">gemfire::CacheableDate</a>, <a class="el" href="classgemfire_1_1CacheableEnum.html#98690cc2b9fd67d2baf6eb14f36ccf10">gemfire::CacheableEnum</a>, and <a class="el" href="classgemfire_1_1CacheableString.html#d7dd96ae41a3534feff3b0a4c789a3b7">gemfire::CacheableString</a>.</p>

</div>
</div><p>
<a class="anchor" name="d8e6541f58ee9574177ae635c62faeba"></a><!-- doxytag: member="gemfire::Struct::typeId" ref="d8e6541f58ee9574177ae635c62faeba" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int8_t gemfire::Struct::typeId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the typeId of <a class="el" href="classgemfire_1_1Struct.html" title="A Struct has a StructSet as its parent.">Struct</a> class. 
<p>

<p>Reimplemented from <a class="el" href="classgemfire_1_1Serializable.html#f5069335ab21d323c8fd4510b4f7d51a">gemfire::Serializable</a>.</p>

</div>
</div><p>
<HR><address style="align: right;"><small>GemFire C++ Cache API Documentation</small></address>
